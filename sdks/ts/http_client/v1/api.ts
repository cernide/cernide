// Copyright 2018-2020 Polyaxon, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Polyaxon SDKs and REST API specification.
 * Polyaxon SDKs and REST API specification.
 *
 * OpenAPI spec version: 1.0.5
 * Contact: contact@polyaxon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AgentStateResponseAgentState
 */
export interface AgentStateResponseAgentState {
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    schedules?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    notifier?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    watchdogs?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    tuners?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    queued?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    stopping?: any;
    /**
     * 
     * @type {any}
     * @memberof AgentStateResponseAgentState
     */
    apply?: any;
    /**
     * 
     * @type {boolean}
     * @memberof AgentStateResponseAgentState
     */
    full?: boolean;
}

/**
 * - plotly: Plotly chart  - bokeh: Bokeh chart  - vega: Vega chart  - roc: ROC chart  - auc: AUC chart  - confusion: Confusion chart
 * @export
 * @enum {string}
 */
export enum EventChartKind {
    Plotly = <any> 'plotly',
    Bokeh = <any> 'bokeh',
    Vega = <any> 'vega',
    Roc = <any> 'roc',
    Auc = <any> 'auc',
    Confusion = <any> 'confusion'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum NotificationTrigger {
    Succeeded = <any> 'succeeded',
    Failed = <any> 'failed',
    Stopped = <any> 'stopped',
    Done = <any> 'done'
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof ProtobufAny
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof ProtobufAny
     */
    value?: string;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
    NULLVALUE = <any> 'NULL_VALUE'
}

/**
 * 
 * @export
 * @interface RuntimeError
 */
export interface RuntimeError {
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof RuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof RuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RuntimeError
     */
    details?: Array<ProtobufAny>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SparkDeployMode {
    Cluster = <any> 'cluster',
    Client = <any> 'client',
    InClusterClient = <any> 'in_cluster_client'
}

/**
 * 
 * @export
 * @interface V1AccessResource
 */
export interface V1AccessResource {
    /**
     * 
     * @type {string}
     * @memberof V1AccessResource
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AccessResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AccessResource
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1AccessResource
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1AccessResource
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1AccessResource
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1AccessResource
     */
    kind?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1AccessResource
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1AccessResource
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1AccessResource
     */
    deleted?: boolean;
}

/**
 * 
 * @export
 * @interface V1Affinity
 */
export interface V1Affinity {
}

/**
 * 
 * @export
 * @interface V1Agent
 */
export interface V1Agent {
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Agent
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Agent
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Agent
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    namespace?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Agent
     */
    version_api?: any;
    /**
     * 
     * @type {string}
     * @memberof V1Agent
     */
    content?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Agent
     */
    concurrency?: number;
    /**
     * 
     * @type {Date}
     * @memberof V1Agent
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Agent
     */
    updated_at?: Date;
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1Agent
     */
    status?: V1Statuses;
}

/**
 * 
 * @export
 * @interface V1AgentStateResponse
 */
export interface V1AgentStateResponse {
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1AgentStateResponse
     */
    status?: V1Statuses;
    /**
     * 
     * @type {AgentStateResponseAgentState}
     * @memberof V1AgentStateResponse
     */
    state?: AgentStateResponseAgentState;
}

/**
 * 
 * @export
 * @interface V1AgentStatusBodyRequest
 */
export interface V1AgentStatusBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1AgentStatusBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AgentStatusBodyRequest
     */
    uuid?: string;
    /**
     * 
     * @type {V1StatusCondition}
     * @memberof V1AgentStatusBodyRequest
     */
    condition?: V1StatusCondition;
}

/**
 * - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
 * @export
 * @enum {string}
 */
export enum V1ArtifactKind {
    Model = <any> 'model',
    Audio = <any> 'audio',
    Video = <any> 'video',
    Histogram = <any> 'histogram',
    Image = <any> 'image',
    Tensor = <any> 'tensor',
    Dataframe = <any> 'dataframe',
    Chart = <any> 'chart',
    Csv = <any> 'csv',
    Tsv = <any> 'tsv',
    Psv = <any> 'psv',
    Ssv = <any> 'ssv',
    Metric = <any> 'metric',
    Env = <any> 'env',
    Html = <any> 'html',
    Text = <any> 'text',
    File = <any> 'file',
    Dir = <any> 'dir',
    Dockerfile = <any> 'dockerfile',
    DockerImage = <any> 'docker_image',
    Data = <any> 'data',
    Coderef = <any> 'coderef',
    Table = <any> 'table'
}

/**
 * 
 * @export
 * @interface V1ArtifactTreeResponse
 */
export interface V1ArtifactTreeResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1ArtifactTreeResponse
     */
    files?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactTreeResponse
     */
    dirs?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactTreeResponse
     */
    is_done?: boolean;
}

/**
 * 
 * @export
 * @interface V1ArtifactsMount
 */
export interface V1ArtifactsMount {
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsMount
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactsMount
     */
    paths?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ArtifactsType
 */
export interface V1ArtifactsType {
    /**
     * 
     * @type {string}
     * @memberof V1ArtifactsType
     */
    connection?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactsType
     */
    files?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ArtifactsType
     */
    dirs?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1ArtifactsType
     */
    init?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1ArtifactsType
     */
    workers?: number;
}

/**
 * 
 * @export
 * @interface V1Auth
 */
export interface V1Auth {
    /**
     * 
     * @type {string}
     * @memberof V1Auth
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface V1AuthType
 */
export interface V1AuthType {
    /**
     * 
     * @type {string}
     * @memberof V1AuthType
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AuthType
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1AverageStoppingPolicy
 */
export interface V1AverageStoppingPolicy {
    /**
     * 
     * @type {any}
     * @memberof V1AverageStoppingPolicy
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1Bayes
 */
export interface V1Bayes {
    /**
     * 
     * @type {string}
     * @memberof V1Bayes
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1Bayes
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1Bayes
     */
    num_initial_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Bayes
     */
    num_iterations?: number;
    /**
     * 
     * @type {any}
     * @memberof V1Bayes
     */
    utility_function?: any;
    /**
     * 
     * @type {V1OptimizationMetric}
     * @memberof V1Bayes
     */
    metric?: V1OptimizationMetric;
    /**
     * 
     * @type {number}
     * @memberof V1Bayes
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Bayes
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Bayes
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1BucketConnection
 */
export interface V1BucketConnection {
    /**
     * 
     * @type {string}
     * @memberof V1BucketConnection
     */
    bucket?: string;
}

/**
 * 
 * @export
 * @interface V1Cache
 */
export interface V1Cache {
    /**
     * 
     * @type {boolean}
     * @memberof V1Cache
     */
    disable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1Cache
     */
    ttl?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Cache
     */
    inputs?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ClaimConnection
 */
export interface V1ClaimConnection {
    /**
     * 
     * @type {string}
     * @memberof V1ClaimConnection
     */
    volume_claim?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ClaimConnection
     */
    mount_path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1ClaimConnection
     */
    read_only?: boolean;
    /**
     * 
     * @type {any}
     * @memberof V1ClaimConnection
     */
    kind?: any;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1CleanPodPolicy {
    All = <any> 'All',
    Running = <any> 'Running',
    None = <any> 'None'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1CloningStrategy {
    Copy = <any> 'copy',
    Restart = <any> 'restart',
    Cache = <any> 'cache',
    Schedule = <any> 'schedule'
}

/**
 * 
 * @export
 * @interface V1CompiledOperation
 */
export interface V1CompiledOperation {
    /**
     * 
     * @type {number}
     * @memberof V1CompiledOperation
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1CompiledOperation
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CompiledOperation
     */
    queue?: string;
    /**
     * 
     * @type {V1Cache}
     * @memberof V1CompiledOperation
     */
    cache?: V1Cache;
    /**
     * 
     * @type {any}
     * @memberof V1CompiledOperation
     */
    schedule?: any;
    /**
     * 
     * @type {any}
     * @memberof V1CompiledOperation
     */
    parallel?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1CompiledOperation
     */
    dependencies?: Array<string>;
    /**
     * 
     * @type {V1TriggerPolicy}
     * @memberof V1CompiledOperation
     */
    trigger?: V1TriggerPolicy;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1CompiledOperation
     */
    conditions?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof V1CompiledOperation
     */
    skip_on_upstream_skip?: boolean;
    /**
     * 
     * @type {V1Termination}
     * @memberof V1CompiledOperation
     */
    termination?: V1Termination;
    /**
     * 
     * @type {V1Plugins}
     * @memberof V1CompiledOperation
     */
    plugins?: V1Plugins;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1CompiledOperation
     */
    inputs?: Array<V1IO>;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1CompiledOperation
     */
    outputs?: Array<V1IO>;
    /**
     * 
     * @type {any}
     * @memberof V1CompiledOperation
     */
    run?: any;
}

/**
 * 
 * @export
 * @interface V1Component
 */
export interface V1Component {
    /**
     * 
     * @type {number}
     * @memberof V1Component
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Component
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Component
     */
    queue?: string;
    /**
     * 
     * @type {V1Cache}
     * @memberof V1Component
     */
    cache?: V1Cache;
    /**
     * 
     * @type {V1Termination}
     * @memberof V1Component
     */
    termination?: V1Termination;
    /**
     * 
     * @type {V1Plugins}
     * @memberof V1Component
     */
    plugins?: V1Plugins;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1Component
     */
    inputs?: Array<V1IO>;
    /**
     * 
     * @type {Array<V1IO>}
     * @memberof V1Component
     */
    outputs?: Array<V1IO>;
    /**
     * 
     * @type {any}
     * @memberof V1Component
     */
    run?: any;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1ConnectionKind {
    HostPath = <any> 'host_path',
    VolumeClaim = <any> 'volume_claim',
    Gcs = <any> 'gcs',
    S3 = <any> 's3',
    Wasb = <any> 'wasb',
    Registry = <any> 'registry',
    Git = <any> 'git',
    Aws = <any> 'aws',
    Gcp = <any> 'gcp',
    Azure = <any> 'azure',
    Mysql = <any> 'mysql',
    Postgres = <any> 'postgres',
    Oracle = <any> 'oracle',
    Vertica = <any> 'vertica',
    Sqlite = <any> 'sqlite',
    Mssql = <any> 'mssql',
    Redis = <any> 'redis',
    Presto = <any> 'presto',
    Mongo = <any> 'mongo',
    Cassandra = <any> 'cassandra',
    Ftp = <any> 'ftp',
    Grpc = <any> 'grpc',
    Hdfs = <any> 'hdfs',
    Http = <any> 'http',
    PigCli = <any> 'pig_cli',
    HiveCli = <any> 'hive_cli',
    HiveMetastore = <any> 'hive_metastore',
    HiveServer2 = <any> 'hive_server2',
    Jdbc = <any> 'jdbc',
    Jenkins = <any> 'jenkins',
    Samba = <any> 'samba',
    Snowflake = <any> 'snowflake',
    Ssh = <any> 'ssh',
    Cloudant = <any> 'cloudant',
    Databricks = <any> 'databricks',
    Segment = <any> 'segment',
    Slack = <any> 'slack',
    Discord = <any> 'discord',
    Mattermost = <any> 'mattermost',
    PagerDuty = <any> 'pager_duty',
    Hipchat = <any> 'hipchat',
    Webhook = <any> 'webhook',
    Custom = <any> 'custom'
}

/**
 * 
 * @export
 * @interface V1ConnectionResponse
 */
export interface V1ConnectionResponse {
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionResponse
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionResponse
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ConnectionResponse
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1ConnectionResponse
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1ConnectionResponse
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConnectionResponse
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConnectionResponse
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1ConnectionResponse
     */
    deleted?: boolean;
    /**
     * 
     * @type {V1ConnectionKind}
     * @memberof V1ConnectionResponse
     */
    kind?: V1ConnectionKind;
}

/**
 * 
 * @export
 * @interface V1ConnectionSchema
 */
export interface V1ConnectionSchema {
    /**
     * 
     * @type {V1BucketConnection}
     * @memberof V1ConnectionSchema
     */
    bucket_connection?: V1BucketConnection;
    /**
     * 
     * @type {V1HostPathConnection}
     * @memberof V1ConnectionSchema
     */
    host_path_connection?: V1HostPathConnection;
    /**
     * 
     * @type {V1ClaimConnection}
     * @memberof V1ConnectionSchema
     */
    claim_connection?: V1ClaimConnection;
    /**
     * 
     * @type {V1HostConnection}
     * @memberof V1ConnectionSchema
     */
    host_connection?: V1HostConnection;
    /**
     * 
     * @type {V1GitConnection}
     * @memberof V1ConnectionSchema
     */
    git_connection?: V1GitConnection;
}

/**
 * 
 * @export
 * @interface V1ConnectionType
 */
export interface V1ConnectionType {
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionType
     */
    name?: string;
    /**
     * 
     * @type {V1ConnectionKind}
     * @memberof V1ConnectionType
     */
    kind?: V1ConnectionKind;
    /**
     * 
     * @type {any}
     * @memberof V1ConnectionType
     */
    schema?: any;
    /**
     * 
     * @type {V1K8sResourceSchema}
     * @memberof V1ConnectionType
     */
    secret?: V1K8sResourceSchema;
    /**
     * 
     * @type {V1K8sResourceSchema}
     * @memberof V1ConnectionType
     */
    config_map?: V1K8sResourceSchema;
}

/**
 * 
 * @export
 * @interface V1Container
 */
export interface V1Container {
}

/**
 * 
 * @export
 * @interface V1CredsBodyRequest
 */
export interface V1CredsBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CredsBodyRequest
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface V1CronSchedule
 */
export interface V1CronSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1CronSchedule
     */
    kind?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1CronSchedule
     */
    start_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1CronSchedule
     */
    end_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1CronSchedule
     */
    cron?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CronSchedule
     */
    depends_on_past?: boolean;
}

/**
 * 
 * @export
 * @interface V1Dag
 */
export interface V1Dag {
    /**
     * 
     * @type {string}
     * @memberof V1Dag
     */
    kind?: string;
    /**
     * 
     * @type {Array<V1Operation>}
     * @memberof V1Dag
     */
    operations?: Array<V1Operation>;
    /**
     * 
     * @type {Array<V1Component>}
     * @memberof V1Dag
     */
    components?: Array<V1Component>;
    /**
     * 
     * @type {number}
     * @memberof V1Dag
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Dag
     */
    early_stopping?: Array<any>;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Dag
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Dag
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Dag
     */
    volumes?: Array<V1Volume>;
}

/**
 * 
 * @export
 * @interface V1DagReference
 */
export interface V1DagReference {
    /**
     * 
     * @type {string}
     * @memberof V1DagReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DagReference
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1Dashboard
 */
export interface V1Dashboard {
    /**
     * 
     * @type {string}
     * @memberof V1Dashboard
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Dashboard
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Dashboard
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Dashboard
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Dashboard
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Dashboard
     */
    deleted?: boolean;
    /**
     * 
     * @type {Array<V1WidgetSpec>}
     * @memberof V1Dashboard
     */
    widgets?: Array<V1WidgetSpec>;
    /**
     * 
     * @type {Date}
     * @memberof V1Dashboard
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Dashboard
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1Dask
 */
export interface V1Dask {
    /**
     * 
     * @type {string}
     * @memberof V1Dask
     */
    kind?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Dask
     */
    scale?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Dask
     */
    adapt_min?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Dask
     */
    adapt_max?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Dask
     */
    adapt_interval?: string;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Dask
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Dask
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Dask
     */
    volumes?: Array<V1Volume>;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1Dask
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1Dask
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Dask
     */
    container?: V1Container;
}

/**
 * Early stopping with diff factor stopping, this policy computes checks runs against the best run and stops those whose performance is worse than the best by the factor defined by the user.
 * @export
 * @interface V1DiffStoppingPolicy
 */
export interface V1DiffStoppingPolicy {
    /**
     * 
     * @type {string}
     * @memberof V1DiffStoppingPolicy
     */
    kind?: string;
    /**
     * 
     * @type {number}
     * @memberof V1DiffStoppingPolicy
     */
    percent?: number;
    /**
     * Interval/Frequency for applying the policy.
     * @type {number}
     * @memberof V1DiffStoppingPolicy
     */
    evaluation_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1DiffStoppingPolicy
     */
    min_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1DiffStoppingPolicy
     */
    min_samples?: number;
}

/**
 * 
 * @export
 * @interface V1DockerfileType
 */
export interface V1DockerfileType {
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    image?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1DockerfileType
     */
    env?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1DockerfileType
     */
    path?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1DockerfileType
     */
    copy?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof V1DockerfileType
     */
    run?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    lang_env?: string;
    /**
     * 
     * @type {number}
     * @memberof V1DockerfileType
     */
    uid?: number;
    /**
     * 
     * @type {number}
     * @memberof V1DockerfileType
     */
    gid?: number;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    filename?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    workdir?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    workdir_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1DockerfileType
     */
    shell?: string;
}

/**
 * 
 * @export
 * @interface V1EarlyStopping
 */
export interface V1EarlyStopping {
    /**
     * 
     * @type {V1MedianStoppingPolicy}
     * @memberof V1EarlyStopping
     */
    median?: V1MedianStoppingPolicy;
    /**
     * 
     * @type {V1DiffStoppingPolicy}
     * @memberof V1EarlyStopping
     */
    diff?: V1DiffStoppingPolicy;
    /**
     * 
     * @type {V1TruncationStoppingPolicy}
     * @memberof V1EarlyStopping
     */
    truncation?: V1TruncationStoppingPolicy;
    /**
     * 
     * @type {V1MetricEarlyStopping}
     * @memberof V1EarlyStopping
     */
    metric?: V1MetricEarlyStopping;
    /**
     * 
     * @type {V1FailureEarlyStopping}
     * @memberof V1EarlyStopping
     */
    failure?: V1FailureEarlyStopping;
}

/**
 * 
 * @export
 * @interface V1EntityNotificationBody
 */
export interface V1EntityNotificationBody {
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityNotificationBody
     */
    name?: string;
    /**
     * 
     * @type {V1StatusCondition}
     * @memberof V1EntityNotificationBody
     */
    condition?: V1StatusCondition;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1EntityNotificationBody
     */
    connections?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1EntityStatusBodyRequest
 */
export interface V1EntityStatusBodyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EntityStatusBodyRequest
     */
    uuid?: string;
    /**
     * 
     * @type {V1StatusCondition}
     * @memberof V1EntityStatusBodyRequest
     */
    condition?: V1StatusCondition;
}

/**
 * 
 * @export
 * @interface V1Environment
 */
export interface V1Environment {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Environment
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Environment
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof V1Environment
     */
    node_selector?: { [key: string]: string; };
    /**
     * Optional Affinity sets the scheduling constraints.
     * @type {V1Affinity}
     * @memberof V1Environment
     */
    affinity?: V1Affinity;
    /**
     * Optional Tolerations to apply.
     * @type {Array<V1Toleration>}
     * @memberof V1Environment
     */
    tolerations?: Array<V1Toleration>;
    /**
     * Optional NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
     * @type {string}
     * @memberof V1Environment
     */
    node_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Environment
     */
    service_account_name?: string;
    /**
     * Optional HostAliases is an optional list of hosts and IPs that will be injected into the pod spec.
     * @type {Array<V1HostAlias>}
     * @memberof V1Environment
     */
    host_aliases?: Array<V1HostAlias>;
    /**
     * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
     * @type {V1PodSecurityContext}
     * @memberof V1Environment
     */
    security_context?: V1PodSecurityContext;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Environment
     */
    image_pull_secrets?: Array<string>;
    /**
     * Host networking requested for this workflow pod. Default to false.
     * @type {boolean}
     * @memberof V1Environment
     */
    host_network?: boolean;
    /**
     * Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
     * @type {string}
     * @memberof V1Environment
     */
    dns_policy?: string;
    /**
     * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
     * @type {V1PodDNSConfig}
     * @memberof V1Environment
     */
    dns_config?: V1PodDNSConfig;
    /**
     * 
     * @type {string}
     * @memberof V1Environment
     */
    scheduler_name?: string;
    /**
     * If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
     * @type {string}
     * @memberof V1Environment
     */
    priority_class_name?: string;
    /**
     * The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.
     * @type {number}
     * @memberof V1Environment
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Environment
     */
    restart_policy?: string;
}

/**
 * 
 * @export
 * @interface V1Event
 */
export interface V1Event {
    /**
     * 
     * @type {Date}
     * @memberof V1Event
     */
    timestamp?: Date;
    /**
     * Global step of the event.
     * @type {number}
     * @memberof V1Event
     */
    step?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Event
     */
    metric?: number;
    /**
     * 
     * @type {V1EventImage}
     * @memberof V1Event
     */
    image?: V1EventImage;
    /**
     * 
     * @type {V1EventHistogram}
     * @memberof V1Event
     */
    histogram?: V1EventHistogram;
    /**
     * 
     * @type {V1EventAudio}
     * @memberof V1Event
     */
    audio?: V1EventAudio;
    /**
     * 
     * @type {V1EventVideo}
     * @memberof V1Event
     */
    video?: V1EventVideo;
    /**
     * 
     * @type {string}
     * @memberof V1Event
     */
    html?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Event
     */
    text?: string;
    /**
     * 
     * @type {V1EventChart}
     * @memberof V1Event
     */
    chart?: V1EventChart;
    /**
     * 
     * @type {V1EventModel}
     * @memberof V1Event
     */
    model?: V1EventModel;
    /**
     * 
     * @type {V1EventArtifact}
     * @memberof V1Event
     */
    artifact?: V1EventArtifact;
    /**
     * 
     * @type {V1EventDataframe}
     * @memberof V1Event
     */
    dataframe?: V1EventDataframe;
}

/**
 * 
 * @export
 * @interface V1EventArtifact
 */
export interface V1EventArtifact {
    /**
     * 
     * @type {V1ArtifactKind}
     * @memberof V1EventArtifact
     */
    kind?: V1ArtifactKind;
    /**
     * 
     * @type {string}
     * @memberof V1EventArtifact
     */
    path?: string;
}

/**
 * 
 * @export
 * @interface V1EventAudio
 */
export interface V1EventAudio {
    /**
     * Sample rate of the audio in Hz.
     * @type {number}
     * @memberof V1EventAudio
     */
    sample_rate?: number;
    /**
     * Number of channels of audio.
     * @type {number}
     * @memberof V1EventAudio
     */
    num_channels?: number;
    /**
     * Length of the audio in frames (samples per channel).
     * @type {number}
     * @memberof V1EventAudio
     */
    length_frames?: number;
    /**
     * 
     * @type {string}
     * @memberof V1EventAudio
     */
    content_type?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventAudio
     */
    path?: string;
}

/**
 * 
 * @export
 * @interface V1EventChart
 */
export interface V1EventChart {
    /**
     * 
     * @type {EventChartKind}
     * @memberof V1EventChart
     */
    kind?: EventChartKind;
    /**
     * 
     * @type {any}
     * @memberof V1EventChart
     */
    figure?: any;
}

/**
 * 
 * @export
 * @interface V1EventDataframe
 */
export interface V1EventDataframe {
    /**
     * 
     * @type {string}
     * @memberof V1EventDataframe
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventDataframe
     */
    content_type?: string;
}

/**
 * 
 * @export
 * @interface V1EventHistogram
 */
export interface V1EventHistogram {
    /**
     * 
     * @type {Array<number>}
     * @memberof V1EventHistogram
     */
    values?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof V1EventHistogram
     */
    counts?: Array<number>;
}

/**
 * 
 * @export
 * @interface V1EventImage
 */
export interface V1EventImage {
    /**
     * Height of the image.
     * @type {number}
     * @memberof V1EventImage
     */
    height?: number;
    /**
     * Width of the image.
     * @type {number}
     * @memberof V1EventImage
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof V1EventImage
     */
    colorspace?: number;
    /**
     * 
     * @type {string}
     * @memberof V1EventImage
     */
    path?: string;
}

/**
 * 
 * @export
 * @interface V1EventModel
 */
export interface V1EventModel {
    /**
     * 
     * @type {string}
     * @memberof V1EventModel
     */
    framework?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventModel
     */
    path?: string;
    /**
     * 
     * @type {any}
     * @memberof V1EventModel
     */
    spec?: any;
}

/**
 * 
 * @export
 * @interface V1EventType
 */
export interface V1EventType {
    /**
     * 
     * @type {string}
     * @memberof V1EventType
     */
    name?: string;
    /**
     * 
     * @type {V1ArtifactKind}
     * @memberof V1EventType
     */
    kind?: V1ArtifactKind;
}

/**
 * 
 * @export
 * @interface V1EventVideo
 */
export interface V1EventVideo {
    /**
     * Height of the video.
     * @type {number}
     * @memberof V1EventVideo
     */
    height?: number;
    /**
     * Width of the video.
     * @type {number}
     * @memberof V1EventVideo
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof V1EventVideo
     */
    colorspace?: number;
    /**
     * 
     * @type {string}
     * @memberof V1EventVideo
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EventVideo
     */
    content_type?: string;
}

/**
 * 
 * @export
 * @interface V1EventsResponse
 */
export interface V1EventsResponse {
    /**
     * 
     * @type {Array<any>}
     * @memberof V1EventsResponse
     */
    data?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1ExactTimeSchedule
 */
export interface V1ExactTimeSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1ExactTimeSchedule
     */
    kind?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1ExactTimeSchedule
     */
    start_at?: Date;
}

/**
 * FailureEarlyStoppingSchema specification Early stopping based on failure config. this policy stops based on a percentage of failed runs at every evaluation.
 * @export
 * @interface V1FailureEarlyStopping
 */
export interface V1FailureEarlyStopping {
    /**
     * 
     * @type {string}
     * @memberof V1FailureEarlyStopping
     */
    kind?: string;
    /**
     * The percentage failed runs, at each evaluation interval. e.g. 1 - 99.
     * @type {number}
     * @memberof V1FailureEarlyStopping
     */
    percent?: number;
    /**
     * Interval/Frequency for applying the policy.
     * @type {string}
     * @memberof V1FailureEarlyStopping
     */
    evaluation_interval?: string;
}

/**
 * 
 * @export
 * @interface V1Flink
 */
export interface V1Flink {
    /**
     * 
     * @type {string}
     * @memberof V1Flink
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Flink
     */
    spec?: any;
}

/**
 * 
 * @export
 * @interface V1GcsType
 */
export interface V1GcsType {
    /**
     * 
     * @type {string}
     * @memberof V1GcsType
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GcsType
     */
    blob?: string;
}

/**
 * 
 * @export
 * @interface V1GitConnection
 */
export interface V1GitConnection {
    /**
     * 
     * @type {string}
     * @memberof V1GitConnection
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1GitConnection
     */
    revision?: boolean;
}

/**
 * 
 * @export
 * @interface V1GitType
 */
export interface V1GitType {
    /**
     * 
     * @type {string}
     * @memberof V1GitType
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1GitType
     */
    revision?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1GitType
     */
    connection?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1GitType
     */
    init?: boolean;
}

/**
 * 
 * @export
 * @interface V1GridSearch
 */
export interface V1GridSearch {
    /**
     * 
     * @type {string}
     * @memberof V1GridSearch
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1GridSearch
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1GridSearch
     */
    num_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1GridSearch
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1GridSearch
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1GridSearch
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1HostAlias
 */
export interface V1HostAlias {
}

/**
 * 
 * @export
 * @interface V1HostConnection
 */
export interface V1HostConnection {
    /**
     * 
     * @type {string}
     * @memberof V1HostConnection
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostConnection
     */
    insecure?: boolean;
}

/**
 * 
 * @export
 * @interface V1HostPathConnection
 */
export interface V1HostPathConnection {
    /**
     * 
     * @type {string}
     * @memberof V1HostPathConnection
     */
    host_path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HostPathConnection
     */
    mount_path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1HostPathConnection
     */
    read_only?: boolean;
    /**
     * 
     * @type {any}
     * @memberof V1HostPathConnection
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1HpChoice
 */
export interface V1HpChoice {
    /**
     * 
     * @type {string}
     * @memberof V1HpChoice
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpChoice
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpGeomSpace
 */
export interface V1HpGeomSpace {
    /**
     * 
     * @type {string}
     * @memberof V1HpGeomSpace
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpGeomSpace
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpLinSpace
 */
export interface V1HpLinSpace {
    /**
     * 
     * @type {string}
     * @memberof V1HpLinSpace
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpLinSpace
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpLogNormal
 */
export interface V1HpLogNormal {
    /**
     * 
     * @type {string}
     * @memberof V1HpLogNormal
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpLogNormal
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpLogSpace
 */
export interface V1HpLogSpace {
    /**
     * 
     * @type {string}
     * @memberof V1HpLogSpace
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpLogSpace
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpLogUniform
 */
export interface V1HpLogUniform {
    /**
     * 
     * @type {string}
     * @memberof V1HpLogUniform
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpLogUniform
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpNormal
 */
export interface V1HpNormal {
    /**
     * 
     * @type {string}
     * @memberof V1HpNormal
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpNormal
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpPChoice
 */
export interface V1HpPChoice {
    /**
     * 
     * @type {string}
     * @memberof V1HpPChoice
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpPChoice
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpQLogNormal
 */
export interface V1HpQLogNormal {
    /**
     * 
     * @type {string}
     * @memberof V1HpQLogNormal
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpQLogNormal
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpQLogUniform
 */
export interface V1HpQLogUniform {
    /**
     * 
     * @type {string}
     * @memberof V1HpQLogUniform
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpQLogUniform
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpQNormal
 */
export interface V1HpQNormal {
    /**
     * 
     * @type {string}
     * @memberof V1HpQNormal
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpQNormal
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpQUniform
 */
export interface V1HpQUniform {
    /**
     * 
     * @type {string}
     * @memberof V1HpQUniform
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpQUniform
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpRange
 */
export interface V1HpRange {
    /**
     * 
     * @type {string}
     * @memberof V1HpRange
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpRange
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HpUniform
 */
export interface V1HpUniform {
    /**
     * 
     * @type {string}
     * @memberof V1HpUniform
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1HpUniform
     */
    value?: any;
}

/**
 * 
 * @export
 * @interface V1HubComponent
 */
export interface V1HubComponent {
    /**
     * 
     * @type {string}
     * @memberof V1HubComponent
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubComponent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubComponent
     */
    tag?: string;
    /**
     * 
     * @type {V1Component}
     * @memberof V1HubComponent
     */
    content?: V1Component;
    /**
     * 
     * @type {string}
     * @memberof V1HubComponent
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1HubComponent
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1HubComponent
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1HubComponent
     */
    deleted?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof V1HubComponent
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1HubComponent
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1HubModel
 */
export interface V1HubModel {
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    framework?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubModel
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1HubModel
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1HubModel
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1HubModel
     */
    deleted?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof V1HubModel
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1HubModel
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1HubReference
 */
export interface V1HubReference {
    /**
     * 
     * @type {string}
     * @memberof V1HubReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1HubReference
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1Hyperband
 */
export interface V1Hyperband {
    /**
     * 
     * @type {string}
     * @memberof V1Hyperband
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1Hyperband
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    max_iterations?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    eta?: number;
    /**
     * 
     * @type {V1OptimizationResource}
     * @memberof V1Hyperband
     */
    resource?: V1OptimizationResource;
    /**
     * 
     * @type {V1OptimizationMetric}
     * @memberof V1Hyperband
     */
    metric?: V1OptimizationMetric;
    /**
     * 
     * @type {boolean}
     * @memberof V1Hyperband
     */
    resume?: boolean;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperband
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Hyperband
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Hyperopt
 */
export interface V1Hyperopt {
    /**
     * 
     * @type {string}
     * @memberof V1Hyperopt
     */
    kind?: string;
    /**
     * 
     * @type {V1HyperoptAlgorithms}
     * @memberof V1Hyperopt
     */
    algorithm?: V1HyperoptAlgorithms;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1Hyperopt
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1Hyperopt
     */
    num_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperopt
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Hyperopt
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Hyperopt
     */
    early_stopping?: Array<any>;
}

/**
 * - tpe: tpe algorithm  - rand: random algorithm  - anneal: anneal algorithm
 * @export
 * @enum {string}
 */
export enum V1HyperoptAlgorithms {
    Tpe = <any> 'tpe',
    Rand = <any> 'rand',
    Anneal = <any> 'anneal'
}

/**
 * 
 * @export
 * @interface V1IO
 */
export interface V1IO {
    /**
     * 
     * @type {string}
     * @memberof V1IO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IO
     */
    iotype?: string;
    /**
     * 
     * @type {any}
     * @memberof V1IO
     */
    value?: any;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    is_optional?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    is_list?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    is_flag?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1IO
     */
    delay_validation?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1IO
     */
    options?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1ImageType
 */
export interface V1ImageType {
    /**
     * 
     * @type {string}
     * @memberof V1ImageType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ImageType
     */
    connection?: string;
}

/**
 * 
 * @export
 * @interface V1Init
 */
export interface V1Init {
    /**
     * 
     * @type {V1ArtifactsType}
     * @memberof V1Init
     */
    artifacts?: V1ArtifactsType;
    /**
     * 
     * @type {V1GitType}
     * @memberof V1Init
     */
    git?: V1GitType;
    /**
     * 
     * @type {V1DockerfileType}
     * @memberof V1Init
     */
    dockerfile?: V1DockerfileType;
    /**
     * 
     * @type {string}
     * @memberof V1Init
     */
    connection?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Init
     */
    path?: string;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Init
     */
    container?: V1Container;
}

/**
 * 
 * @export
 * @interface V1IntervalSchedule
 */
export interface V1IntervalSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1IntervalSchedule
     */
    kind?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1IntervalSchedule
     */
    start_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1IntervalSchedule
     */
    end_at?: Date;
    /**
     * 
     * @type {number}
     * @memberof V1IntervalSchedule
     */
    frequency?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1IntervalSchedule
     */
    depends_on_past?: boolean;
}

/**
 * 
 * @export
 * @interface V1IoCond
 */
export interface V1IoCond {
    /**
     * 
     * @type {string}
     * @memberof V1IoCond
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IoCond
     */
    param?: string;
    /**
     * 
     * @type {string}
     * @memberof V1IoCond
     */
    trigger?: string;
}

/**
 * 
 * @export
 * @interface V1Iterative
 */
export interface V1Iterative {
    /**
     * 
     * @type {string}
     * @memberof V1Iterative
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1Iterative
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1Iterative
     */
    num_iterations?: number;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Iterative
     */
    container?: V1Container;
    /**
     * 
     * @type {number}
     * @memberof V1Iterative
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Iterative
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Iterative
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Job
 */
export interface V1Job {
    /**
     * 
     * @type {string}
     * @memberof V1Job
     */
    kind?: string;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Job
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Job
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Job
     */
    volumes?: Array<V1Volume>;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1Job
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1Job
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Job
     */
    container?: V1Container;
}

/**
 * 
 * @export
 * @interface V1K8sResourceSchema
 */
export interface V1K8sResourceSchema {
    /**
     * 
     * @type {string}
     * @memberof V1K8sResourceSchema
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1K8sResourceSchema
     */
    mount_path?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1K8sResourceSchema
     */
    items?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1K8sResourceType
 */
export interface V1K8sResourceType {
    /**
     * 
     * @type {string}
     * @memberof V1K8sResourceType
     */
    name?: string;
    /**
     * 
     * @type {V1K8sResourceSchema}
     * @memberof V1K8sResourceType
     */
    schema?: V1K8sResourceSchema;
    /**
     * 
     * @type {boolean}
     * @memberof V1K8sResourceType
     */
    is_requested?: boolean;
}

/**
 * 
 * @export
 * @interface V1KFReplica
 */
export interface V1KFReplica {
    /**
     * 
     * @type {number}
     * @memberof V1KFReplica
     */
    replicas?: number;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1KFReplica
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1KFReplica
     */
    connections?: Array<string>;
    /**
     * 
     * @type {Array<V1Volume>}
     * @memberof V1KFReplica
     */
    volumes?: Array<V1Volume>;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1KFReplica
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1KFReplica
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1KFReplica
     */
    container?: V1Container;
}

/**
 * 
 * @export
 * @interface V1ListAccessResourcesResponse
 */
export interface V1ListAccessResourcesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListAccessResourcesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1AccessResource>}
     * @memberof V1ListAccessResourcesResponse
     */
    results?: Array<V1AccessResource>;
    /**
     * 
     * @type {string}
     * @memberof V1ListAccessResourcesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListAccessResourcesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListAgentsResponse
 */
export interface V1ListAgentsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListAgentsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Agent>}
     * @memberof V1ListAgentsResponse
     */
    results?: Array<V1Agent>;
    /**
     * 
     * @type {string}
     * @memberof V1ListAgentsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListAgentsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListConnectionsResponse
 */
export interface V1ListConnectionsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListConnectionsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1ConnectionResponse>}
     * @memberof V1ListConnectionsResponse
     */
    results?: Array<V1ConnectionResponse>;
    /**
     * 
     * @type {string}
     * @memberof V1ListConnectionsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListConnectionsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListDashboardsResponse
 */
export interface V1ListDashboardsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListDashboardsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Dashboard>}
     * @memberof V1ListDashboardsResponse
     */
    results?: Array<V1Dashboard>;
    /**
     * 
     * @type {string}
     * @memberof V1ListDashboardsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListDashboardsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListHubComponentsResponse
 */
export interface V1ListHubComponentsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListHubComponentsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1HubComponent>}
     * @memberof V1ListHubComponentsResponse
     */
    results?: Array<V1HubComponent>;
    /**
     * 
     * @type {string}
     * @memberof V1ListHubComponentsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListHubComponentsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListHubModelsResponse
 */
export interface V1ListHubModelsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListHubModelsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1HubModel>}
     * @memberof V1ListHubModelsResponse
     */
    results?: Array<V1HubModel>;
    /**
     * 
     * @type {string}
     * @memberof V1ListHubModelsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListHubModelsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListOrganizationMembersResponse
 */
export interface V1ListOrganizationMembersResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListOrganizationMembersResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1OrganizationMember>}
     * @memberof V1ListOrganizationMembersResponse
     */
    results?: Array<V1OrganizationMember>;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationMembersResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationMembersResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListOrganizationsResponse
 */
export interface V1ListOrganizationsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListOrganizationsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Organization>}
     * @memberof V1ListOrganizationsResponse
     */
    results?: Array<V1Organization>;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListOrganizationsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListProjectsResponse
 */
export interface V1ListProjectsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListProjectsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Project>}
     * @memberof V1ListProjectsResponse
     */
    results?: Array<V1Project>;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListProjectsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListQueuesResponse
 */
export interface V1ListQueuesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListQueuesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Queue>}
     * @memberof V1ListQueuesResponse
     */
    results?: Array<V1Queue>;
    /**
     * 
     * @type {string}
     * @memberof V1ListQueuesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListQueuesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunArtifactsResponse
 */
export interface V1ListRunArtifactsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunArtifactsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1RunArtifact>}
     * @memberof V1ListRunArtifactsResponse
     */
    results?: Array<V1RunArtifact>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunArtifactsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunArtifactsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunProfilesResponse
 */
export interface V1ListRunProfilesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunProfilesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1RunProfile>}
     * @memberof V1ListRunProfilesResponse
     */
    results?: Array<V1RunProfile>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunProfilesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunProfilesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListRunsResponse
 */
export interface V1ListRunsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListRunsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Run>}
     * @memberof V1ListRunsResponse
     */
    results?: Array<V1Run>;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListRunsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListSearchesResponse
 */
export interface V1ListSearchesResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListSearchesResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Search>}
     * @memberof V1ListSearchesResponse
     */
    results?: Array<V1Search>;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListSearchesResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListTeamMembersResponse
 */
export interface V1ListTeamMembersResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListTeamMembersResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1TeamMember>}
     * @memberof V1ListTeamMembersResponse
     */
    results?: Array<V1TeamMember>;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamMembersResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamMembersResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1ListTeamsResponse
 */
export interface V1ListTeamsResponse {
    /**
     * 
     * @type {number}
     * @memberof V1ListTeamsResponse
     */
    count?: number;
    /**
     * 
     * @type {Array<V1Team>}
     * @memberof V1ListTeamsResponse
     */
    results?: Array<V1Team>;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamsResponse
     */
    previous?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ListTeamsResponse
     */
    next?: string;
}

/**
 * 
 * @export
 * @interface V1Log
 */
export interface V1Log {
    /**
     * 
     * @type {Date}
     * @memberof V1Log
     */
    timestamp?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Log
     */
    node?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Log
     */
    pod?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Log
     */
    container?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Log
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface V1LogHandler
 */
export interface V1LogHandler {
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    dsn?: string;
    /**
     * 
     * @type {string}
     * @memberof V1LogHandler
     */
    environment?: string;
}

/**
 * 
 * @export
 * @interface V1Logs
 */
export interface V1Logs {
    /**
     * 
     * @type {Array<V1Log>}
     * @memberof V1Logs
     */
    logs?: Array<V1Log>;
    /**
     * 
     * @type {Date}
     * @memberof V1Logs
     */
    last_time?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Logs
     */
    last_file?: string;
}

/**
 * 
 * @export
 * @interface V1MPIJob
 */
export interface V1MPIJob {
    /**
     * 
     * @type {string}
     * @memberof V1MPIJob
     */
    kind?: string;
    /**
     * 
     * @type {V1CleanPodPolicy}
     * @memberof V1MPIJob
     */
    cleanPodPolicy?: V1CleanPodPolicy;
    /**
     * 
     * @type {number}
     * @memberof V1MPIJob
     */
    slots_per_worker?: number;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1MPIJob
     */
    launcher?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1MPIJob
     */
    worker?: V1KFReplica;
}

/**
 * 
 * @export
 * @interface V1Mapping
 */
export interface V1Mapping {
    /**
     * 
     * @type {string}
     * @memberof V1Mapping
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Mapping
     */
    values?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Mapping
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Mapping
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Matrix
 */
export interface V1Matrix {
    /**
     * 
     * @type {V1HpChoice}
     * @memberof V1Matrix
     */
    choice?: V1HpChoice;
    /**
     * 
     * @type {V1HpPChoice}
     * @memberof V1Matrix
     */
    pchoice?: V1HpPChoice;
    /**
     * 
     * @type {V1HpRange}
     * @memberof V1Matrix
     */
    range?: V1HpRange;
    /**
     * 
     * @type {V1HpLinSpace}
     * @memberof V1Matrix
     */
    linspace?: V1HpLinSpace;
    /**
     * 
     * @type {V1HpLogSpace}
     * @memberof V1Matrix
     */
    logspace?: V1HpLogSpace;
    /**
     * 
     * @type {V1HpGeomSpace}
     * @memberof V1Matrix
     */
    geomspace?: V1HpGeomSpace;
    /**
     * 
     * @type {V1HpUniform}
     * @memberof V1Matrix
     */
    uniform?: V1HpUniform;
    /**
     * 
     * @type {V1HpQUniform}
     * @memberof V1Matrix
     */
    quniform?: V1HpQUniform;
    /**
     * 
     * @type {V1HpLogUniform}
     * @memberof V1Matrix
     */
    loguniform?: V1HpLogUniform;
    /**
     * 
     * @type {V1HpQLogUniform}
     * @memberof V1Matrix
     */
    qloguniform?: V1HpQLogUniform;
    /**
     * 
     * @type {V1HpNormal}
     * @memberof V1Matrix
     */
    normal?: V1HpNormal;
    /**
     * 
     * @type {V1HpQNormal}
     * @memberof V1Matrix
     */
    qnormal?: V1HpQNormal;
    /**
     * 
     * @type {V1HpLogNormal}
     * @memberof V1Matrix
     */
    lognormal?: V1HpLogNormal;
    /**
     * 
     * @type {V1HpQLogNormal}
     * @memberof V1Matrix
     */
    qlognormal?: V1HpQLogNormal;
}

/**
 * 
 * @export
 * @interface V1MatrixChoice
 */
export interface V1MatrixChoice {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixChoice
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixGeomSpace
 */
export interface V1MatrixGeomSpace {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixGeomSpace
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixLinSpace
 */
export interface V1MatrixLinSpace {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixLinSpace
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixLogNormal
 */
export interface V1MatrixLogNormal {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixLogNormal
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixLogSpace
 */
export interface V1MatrixLogSpace {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixLogSpace
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixLogUniform
 */
export interface V1MatrixLogUniform {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixLogUniform
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixNormal
 */
export interface V1MatrixNormal {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixNormal
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixPChoice
 */
export interface V1MatrixPChoice {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixPChoice
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixQLogNormal
 */
export interface V1MatrixQLogNormal {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixQLogNormal
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixQLogUniform
 */
export interface V1MatrixQLogUniform {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixQLogUniform
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixQNormal
 */
export interface V1MatrixQNormal {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixQNormal
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixQUniform
 */
export interface V1MatrixQUniform {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixQUniform
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixRange
 */
export interface V1MatrixRange {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixRange
     */
    kind?: any;
}

/**
 * 
 * @export
 * @interface V1MatrixUniform
 */
export interface V1MatrixUniform {
    /**
     * 
     * @type {any}
     * @memberof V1MatrixUniform
     */
    kind?: any;
}

/**
 * Early stopping with median stopping, this policy computes running medians across all runs and stops those whose best performance is worse than the median of the running runs.
 * @export
 * @interface V1MedianStoppingPolicy
 */
export interface V1MedianStoppingPolicy {
    /**
     * 
     * @type {string}
     * @memberof V1MedianStoppingPolicy
     */
    kind?: string;
    /**
     * Interval/Frequency for applying the policy.
     * @type {number}
     * @memberof V1MedianStoppingPolicy
     */
    evaluation_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1MedianStoppingPolicy
     */
    min_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1MedianStoppingPolicy
     */
    min_samples?: number;
}

/**
 * MetricEarlyStoppingSchema specification Early stopping based on metric config.
 * @export
 * @interface V1MetricEarlyStopping
 */
export interface V1MetricEarlyStopping {
    /**
     * 
     * @type {string}
     * @memberof V1MetricEarlyStopping
     */
    kind?: string;
    /**
     * Metric name to use for early stopping.
     * @type {string}
     * @memberof V1MetricEarlyStopping
     */
    metric?: string;
    /**
     * Metric value to use for the condition.
     * @type {string}
     * @memberof V1MetricEarlyStopping
     */
    value?: string;
    /**
     * Optimization to do: maximize or minimize.
     * @type {V1Optimization}
     * @memberof V1MetricEarlyStopping
     */
    optimization?: V1Optimization;
    /**
     * 
     * @type {any}
     * @memberof V1MetricEarlyStopping
     */
    policy?: any;
}

/**
 * 
 * @export
 * @interface V1Notification
 */
export interface V1Notification {
    /**
     * 
     * @type {string}
     * @memberof V1Notification
     */
    connection?: string;
    /**
     * 
     * @type {NotificationTrigger}
     * @memberof V1Notification
     */
    trigger?: NotificationTrigger;
}

/**
 * 
 * @export
 * @interface V1Operation
 */
export interface V1Operation {
    /**
     * 
     * @type {number}
     * @memberof V1Operation
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Operation
     */
    tags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    queue?: string;
    /**
     * 
     * @type {V1Cache}
     * @memberof V1Operation
     */
    cache?: V1Cache;
    /**
     * 
     * @type {any}
     * @memberof V1Operation
     */
    schedule?: any;
    /**
     * 
     * @type {any}
     * @memberof V1Operation
     */
    parallel?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Operation
     */
    dependencies?: Array<string>;
    /**
     * 
     * @type {V1TriggerPolicy}
     * @memberof V1Operation
     */
    trigger?: V1TriggerPolicy;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1Operation
     */
    conditions?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Operation
     */
    skip_on_upstream_skip?: boolean;
    /**
     * 
     * @type {V1Termination}
     * @memberof V1Operation
     */
    termination?: V1Termination;
    /**
     * 
     * @type {V1Plugins}
     * @memberof V1Operation
     */
    plugins?: V1Plugins;
    /**
     * 
     * @type {{ [key: string]: V1Param; }}
     * @memberof V1Operation
     */
    params?: { [key: string]: V1Param; };
    /**
     * 
     * @type {any}
     * @memberof V1Operation
     */
    run_patch?: any;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    dag_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    url_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    path_ref?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Operation
     */
    hub_ref?: string;
    /**
     * 
     * @type {V1Component}
     * @memberof V1Operation
     */
    component?: V1Component;
}

/**
 * 
 * @export
 * @interface V1OperationBody
 */
export interface V1OperationBody {
    /**
     * 
     * @type {V1Operation}
     * @memberof V1OperationBody
     */
    content?: V1Operation;
    /**
     * 
     * @type {boolean}
     * @memberof V1OperationBody
     */
    is_managed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1OperationBody
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OperationBody
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1OperationBody
     */
    tags?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1OperationCond
 */
export interface V1OperationCond {
    /**
     * 
     * @type {V1IoCond}
     * @memberof V1OperationCond
     */
    io_conidtion?: V1IoCond;
    /**
     * 
     * @type {V1StatusCond}
     * @memberof V1OperationCond
     */
    status_condition?: V1StatusCond;
}

/**
 * - maximize: Minimize a metric  - minimize: Minimize a metric
 * @export
 * @enum {string}
 */
export enum V1Optimization {
    Maximize = <any> 'maximize',
    Minimize = <any> 'minimize'
}

/**
 * 
 * @export
 * @interface V1OptimizationMetric
 */
export interface V1OptimizationMetric {
    /**
     * 
     * @type {string}
     * @memberof V1OptimizationMetric
     */
    name?: string;
    /**
     * 
     * @type {V1Optimization}
     * @memberof V1OptimizationMetric
     */
    optimization?: V1Optimization;
}

/**
 * 
 * @export
 * @interface V1OptimizationResource
 */
export interface V1OptimizationResource {
    /**
     * 
     * @type {string}
     * @memberof V1OptimizationResource
     */
    name?: string;
    /**
     * 
     * @type {V1ResourceType}
     * @memberof V1OptimizationResource
     */
    type?: V1ResourceType;
}

/**
 * 
 * @export
 * @interface V1Organization
 */
export interface V1Organization {
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Organization
     */
    is_public?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Organization
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Organization
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1OrganizationMember
 */
export interface V1OrganizationMember {
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1OrganizationMember
     */
    role?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1OrganizationMember
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1OrganizationMember
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1Parallel
 */
export interface V1Parallel {
    /**
     * 
     * @type {V1RandomSearch}
     * @memberof V1Parallel
     */
    random?: V1RandomSearch;
    /**
     * 
     * @type {V1GridSearch}
     * @memberof V1Parallel
     */
    grid?: V1GridSearch;
    /**
     * 
     * @type {V1Hyperband}
     * @memberof V1Parallel
     */
    hyperband?: V1Hyperband;
    /**
     * 
     * @type {V1Bayes}
     * @memberof V1Parallel
     */
    bayes?: V1Bayes;
    /**
     * 
     * @type {V1Hyperopt}
     * @memberof V1Parallel
     */
    hyperopt?: V1Hyperopt;
    /**
     * 
     * @type {V1Iterative}
     * @memberof V1Parallel
     */
    iterative?: V1Iterative;
    /**
     * 
     * @type {V1Mapping}
     * @memberof V1Parallel
     */
    mapping?: V1Mapping;
}

/**
 * 
 * @export
 * @interface V1Param
 */
export interface V1Param {
    /**
     * 
     * @type {any}
     * @memberof V1Param
     */
    value?: any;
    /**
     * 
     * @type {string}
     * @memberof V1Param
     */
    ref?: string;
    /**
     * 
     * @type {V1ParamSearch}
     * @memberof V1Param
     */
    search?: V1ParamSearch;
}

/**
 * 
 * @export
 * @interface V1ParamSearch
 */
export interface V1ParamSearch {
    /**
     * 
     * @type {string}
     * @memberof V1ParamSearch
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ParamSearch
     */
    sort?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ParamSearch
     */
    limit?: string;
}

/**
 * 
 * @export
 * @interface V1PathReference
 */
export interface V1PathReference {
    /**
     * 
     * @type {string}
     * @memberof V1PathReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PathReference
     */
    path?: string;
}

/**
 * 
 * @export
 * @interface V1Plugins
 */
export interface V1Plugins {
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    auth?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    docker?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    shm?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    collect_artifacts?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    collect_logs?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Plugins
     */
    collect_resources?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Plugins
     */
    sync_statuses?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Plugins
     */
    log_level?: string;
    /**
     * 
     * @type {Array<V1Notification>}
     * @memberof V1Plugins
     */
    notifications?: Array<V1Notification>;
}

/**
 * 
 * @export
 * @interface V1PodDNSConfig
 */
export interface V1PodDNSConfig {
}

/**
 * 
 * @export
 * @interface V1PodSecurityContext
 */
export interface V1PodSecurityContext {
}

/**
 * 
 * @export
 * @interface V1PolyaxonInitContainer
 */
export interface V1PolyaxonInitContainer {
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonInitContainer
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonInitContainer
     */
    image_tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonInitContainer
     */
    image_pull_policy?: string;
    /**
     * 
     * @type {V1ResourceRequirements}
     * @memberof V1PolyaxonInitContainer
     */
    resources?: V1ResourceRequirements;
}

/**
 * 
 * @export
 * @interface V1PolyaxonSidecarContainer
 */
export interface V1PolyaxonSidecarContainer {
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonSidecarContainer
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonSidecarContainer
     */
    image_tag?: string;
    /**
     * 
     * @type {string}
     * @memberof V1PolyaxonSidecarContainer
     */
    image_pull_policy?: string;
    /**
     * 
     * @type {number}
     * @memberof V1PolyaxonSidecarContainer
     */
    sleep_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1PolyaxonSidecarContainer
     */
    sync_interval?: number;
    /**
     * 
     * @type {V1ResourceRequirements}
     * @memberof V1PolyaxonSidecarContainer
     */
    resources?: V1ResourceRequirements;
}

/**
 * 
 * @export
 * @interface V1Project
 */
export interface V1Project {
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Project
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Project
     */
    updated_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    is_public?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    deleted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Project
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Project
     */
    readme?: string;
    /**
     * 
     * @type {V1ProjectSettings}
     * @memberof V1Project
     */
    settings?: V1ProjectSettings;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Project
     */
    teams?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ProjectEntityResourceRequest
 */
export interface V1ProjectEntityResourceRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectEntityResourceRequest
     */
    uuid?: string;
}

/**
 * 
 * @export
 * @interface V1ProjectSettings
 */
export interface V1ProjectSettings {
    /**
     * 
     * @type {string}
     * @memberof V1ProjectSettings
     */
    artifacts_store?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectSettings
     */
    connections?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof V1ProjectSettings
     */
    run_profile?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectSettings
     */
    run_profiles?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1ProjectTeams
 */
export interface V1ProjectTeams {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1ProjectTeams
     */
    teams?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1PytorchJob
 */
export interface V1PytorchJob {
    /**
     * 
     * @type {string}
     * @memberof V1PytorchJob
     */
    kind?: string;
    /**
     * 
     * @type {V1CleanPodPolicy}
     * @memberof V1PytorchJob
     */
    cleanPodPolicy?: V1CleanPodPolicy;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1PytorchJob
     */
    master?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1PytorchJob
     */
    worker?: V1KFReplica;
}

/**
 * 
 * @export
 * @interface V1Queue
 */
export interface V1Queue {
    /**
     * 
     * @type {string}
     * @memberof V1Queue
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Queue
     */
    agent?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Queue
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof V1Queue
     */
    priority?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Queue
     */
    concurrency?: number;
    /**
     * 
     * @type {Date}
     * @memberof V1Queue
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Queue
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1RandomSearch
 */
export interface V1RandomSearch {
    /**
     * 
     * @type {string}
     * @memberof V1RandomSearch
     */
    kind?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof V1RandomSearch
     */
    params?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof V1RandomSearch
     */
    num_runs?: number;
    /**
     * 
     * @type {number}
     * @memberof V1RandomSearch
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof V1RandomSearch
     */
    concurrency?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof V1RandomSearch
     */
    early_stopping?: Array<any>;
}

/**
 * 
 * @export
 * @interface V1Ray
 */
export interface V1Ray {
    /**
     * 
     * @type {string}
     * @memberof V1Ray
     */
    kind?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Ray
     */
    spec?: any;
}

/**
 * 
 * @export
 * @interface V1Reference
 */
export interface V1Reference {
    /**
     * 
     * @type {V1HubReference}
     * @memberof V1Reference
     */
    hub_reference?: V1HubReference;
    /**
     * 
     * @type {V1DagReference}
     * @memberof V1Reference
     */
    dag_reference?: V1DagReference;
    /**
     * 
     * @type {V1UrlReference}
     * @memberof V1Reference
     */
    url_reference?: V1UrlReference;
    /**
     * 
     * @type {V1PathReference}
     * @memberof V1Reference
     */
    path_reference?: V1PathReference;
}

/**
 * 
 * @export
 * @interface V1RepeatableSchedule
 */
export interface V1RepeatableSchedule {
    /**
     * 
     * @type {string}
     * @memberof V1RepeatableSchedule
     */
    kind?: string;
    /**
     * 
     * @type {number}
     * @memberof V1RepeatableSchedule
     */
    limit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1RepeatableSchedule
     */
    depends_on_past?: boolean;
}

/**
 * 
 * @export
 * @interface V1ResourceRequirements
 */
export interface V1ResourceRequirements {
}

/**
 * - int: Int resource  - float: Float resource
 * @export
 * @enum {string}
 */
export enum V1ResourceType {
    Int = <any> 'int',
    Float = <any> 'float'
}

/**
 * 
 * @export
 * @interface V1Run
 */
export interface V1Run {
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Run
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    deleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    project?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    updated_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    started_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Run
     */
    finished_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    is_managed?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    content?: string;
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1Run
     */
    status?: V1Statuses;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    bookmarked?: boolean;
    /**
     * 
     * @type {any}
     * @memberof V1Run
     */
    meta_info?: any;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_helper?: boolean;
    /**
     * 
     * @type {V1RunKind}
     * @memberof V1Run
     */
    kind?: V1RunKind;
    /**
     * 
     * @type {V1RunKind}
     * @memberof V1Run
     */
    meta_kind?: V1RunKind;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    hub?: string;
    /**
     * 
     * @type {any}
     * @memberof V1Run
     */
    inputs?: any;
    /**
     * 
     * @type {any}
     * @memberof V1Run
     */
    outputs?: any;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_resume?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Run
     */
    is_clone?: boolean;
    /**
     * 
     * @type {V1CloningStrategy}
     * @memberof V1Run
     */
    cloning_strategy?: V1CloningStrategy;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    pipeline_name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Run
     */
    original_name?: string;
    /**
     * 
     * @type {Array<V1StatusCondition>}
     * @memberof V1Run
     */
    status_conditions?: Array<V1StatusCondition>;
}

/**
 * 
 * @export
 * @interface V1RunArtifact
 */
export interface V1RunArtifact {
    /**
     * 
     * @type {string}
     * @memberof V1RunArtifact
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunArtifact
     */
    state?: string;
    /**
     * 
     * @type {V1ArtifactKind}
     * @memberof V1RunArtifact
     */
    kind?: V1ArtifactKind;
    /**
     * 
     * @type {string}
     * @memberof V1RunArtifact
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunArtifact
     */
    connection?: string;
    /**
     * 
     * @type {any}
     * @memberof V1RunArtifact
     */
    summary?: any;
    /**
     * 
     * @type {boolean}
     * @memberof V1RunArtifact
     */
    is_input?: boolean;
}

/**
 * 
 * @export
 * @interface V1RunArtifacts
 */
export interface V1RunArtifacts {
    /**
     * 
     * @type {Array<V1RunArtifact>}
     * @memberof V1RunArtifacts
     */
    artifacts?: Array<V1RunArtifact>;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1RunKind {
    Job = <any> 'job',
    Service = <any> 'service',
    Dag = <any> 'dag',
    Spark = <any> 'spark',
    Dask = <any> 'dask',
    Flink = <any> 'flink',
    Ray = <any> 'ray',
    Mpijob = <any> 'mpijob',
    Tfjob = <any> 'tfjob',
    Pytorchjob = <any> 'pytorchjob',
    Parallel = <any> 'parallel',
    Scheduler = <any> 'scheduler',
    Tuner = <any> 'tuner',
    Watchdog = <any> 'watchdog',
    Notifier = <any> 'notifier'
}

/**
 * 
 * @export
 * @interface V1RunProfile
 */
export interface V1RunProfile {
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1RunProfile
     */
    tags?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1RunProfile
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1RunProfile
     */
    updated_at?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof V1RunProfile
     */
    frozen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1RunProfile
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    agent?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    queue?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunProfile
     */
    namespace?: string;
    /**
     * 
     * @type {any}
     * @memberof V1RunProfile
     */
    termination?: any;
    /**
     * 
     * @type {any}
     * @memberof V1RunProfile
     */
    environment?: any;
}

/**
 * 
 * @export
 * @interface V1RunSchema
 */
export interface V1RunSchema {
    /**
     * 
     * @type {V1Job}
     * @memberof V1RunSchema
     */
    job?: V1Job;
    /**
     * 
     * @type {V1Service}
     * @memberof V1RunSchema
     */
    service?: V1Service;
    /**
     * 
     * @type {V1Dag}
     * @memberof V1RunSchema
     */
    dag?: V1Dag;
    /**
     * 
     * @type {V1TFJob}
     * @memberof V1RunSchema
     */
    tf_job?: V1TFJob;
    /**
     * 
     * @type {V1PytorchJob}
     * @memberof V1RunSchema
     */
    pytorch_job?: V1PytorchJob;
    /**
     * 
     * @type {V1MPIJob}
     * @memberof V1RunSchema
     */
    mpi_job?: V1MPIJob;
    /**
     * 
     * @type {V1Dask}
     * @memberof V1RunSchema
     */
    dask?: V1Dask;
    /**
     * 
     * @type {V1Spark}
     * @memberof V1RunSchema
     */
    spark?: V1Spark;
    /**
     * 
     * @type {V1Flink}
     * @memberof V1RunSchema
     */
    flink?: V1Flink;
    /**
     * 
     * @type {V1Ray}
     * @memberof V1RunSchema
     */
    ruy?: V1Ray;
}

/**
 * 
 * @export
 * @interface V1RunSettings
 */
export interface V1RunSettings {
    /**
     * 
     * @type {string}
     * @memberof V1RunSettings
     */
    namespace?: string;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    agent?: V1RunSettingsCatalog;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    queue?: V1RunSettingsCatalog;
    /**
     * 
     * @type {V1RunSettingsCatalog}
     * @memberof V1RunSettings
     */
    artifacts_store?: V1RunSettingsCatalog;
    /**
     * 
     * @type {Array<V1RunSettingsCatalog>}
     * @memberof V1RunSettings
     */
    connections?: Array<V1RunSettingsCatalog>;
}

/**
 * 
 * @export
 * @interface V1RunSettingsCatalog
 */
export interface V1RunSettingsCatalog {
    /**
     * 
     * @type {string}
     * @memberof V1RunSettingsCatalog
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RunSettingsCatalog
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface V1S3Type
 */
export interface V1S3Type {
    /**
     * 
     * @type {string}
     * @memberof V1S3Type
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof V1S3Type
     */
    key?: string;
}

/**
 * 
 * @export
 * @interface V1Schedule
 */
export interface V1Schedule {
    /**
     * 
     * @type {V1CronSchedule}
     * @memberof V1Schedule
     */
    cron?: V1CronSchedule;
    /**
     * 
     * @type {V1ExactTimeSchedule}
     * @memberof V1Schedule
     */
    exact_time?: V1ExactTimeSchedule;
    /**
     * 
     * @type {V1IntervalSchedule}
     * @memberof V1Schedule
     */
    interval?: V1IntervalSchedule;
    /**
     * 
     * @type {V1RepeatableSchedule}
     * @memberof V1Schedule
     */
    repeatable?: V1RepeatableSchedule;
}

/**
 * 
 * @export
 * @interface V1Schemas
 */
export interface V1Schemas {
    /**
     * 
     * @type {V1OperationCond}
     * @memberof V1Schemas
     */
    operation_cond?: V1OperationCond;
    /**
     * 
     * @type {V1EarlyStopping}
     * @memberof V1Schemas
     */
    early_stopping?: V1EarlyStopping;
    /**
     * 
     * @type {V1Parallel}
     * @memberof V1Schemas
     */
    parallel?: V1Parallel;
    /**
     * 
     * @type {V1RunSchema}
     * @memberof V1Schemas
     */
    run?: V1RunSchema;
    /**
     * 
     * @type {V1CompiledOperation}
     * @memberof V1Schemas
     */
    compiled_operation?: V1CompiledOperation;
    /**
     * 
     * @type {V1Schedule}
     * @memberof V1Schemas
     */
    schedule?: V1Schedule;
    /**
     * 
     * @type {V1ConnectionSchema}
     * @memberof V1Schemas
     */
    connection_schema?: V1ConnectionSchema;
    /**
     * 
     * @type {V1Matrix}
     * @memberof V1Schemas
     */
    matrix?: V1Matrix;
    /**
     * 
     * @type {V1Reference}
     * @memberof V1Schemas
     */
    refrence?: V1Reference;
    /**
     * 
     * @type {V1ArtifactsMount}
     * @memberof V1Schemas
     */
    artifacts_mount?: V1ArtifactsMount;
    /**
     * 
     * @type {V1PolyaxonSidecarContainer}
     * @memberof V1Schemas
     */
    polyaxon_sidecar_container?: V1PolyaxonSidecarContainer;
    /**
     * 
     * @type {V1PolyaxonInitContainer}
     * @memberof V1Schemas
     */
    polyaxon_init_container?: V1PolyaxonInitContainer;
    /**
     * 
     * @type {V1ArtifactsType}
     * @memberof V1Schemas
     */
    artifacs?: V1ArtifactsType;
    /**
     * 
     * @type {V1WasbType}
     * @memberof V1Schemas
     */
    wasb?: V1WasbType;
    /**
     * 
     * @type {V1GcsType}
     * @memberof V1Schemas
     */
    gcs?: V1GcsType;
    /**
     * 
     * @type {V1S3Type}
     * @memberof V1Schemas
     */
    s3?: V1S3Type;
    /**
     * 
     * @type {V1AuthType}
     * @memberof V1Schemas
     */
    autg?: V1AuthType;
    /**
     * 
     * @type {V1DockerfileType}
     * @memberof V1Schemas
     */
    dockerfile?: V1DockerfileType;
    /**
     * 
     * @type {V1GitType}
     * @memberof V1Schemas
     */
    git?: V1GitType;
    /**
     * 
     * @type {V1UriType}
     * @memberof V1Schemas
     */
    uri?: V1UriType;
    /**
     * 
     * @type {V1K8sResourceType}
     * @memberof V1Schemas
     */
    k8s_resource?: V1K8sResourceType;
    /**
     * 
     * @type {V1ConnectionType}
     * @memberof V1Schemas
     */
    connection?: V1ConnectionType;
    /**
     * 
     * @type {V1ImageType}
     * @memberof V1Schemas
     */
    image?: V1ImageType;
    /**
     * 
     * @type {V1EventType}
     * @memberof V1Schemas
     */
    event_type?: V1EventType;
    /**
     * 
     * @type {V1Event}
     * @memberof V1Schemas
     */
    event?: V1Event;
}

/**
 * 
 * @export
 * @interface V1Search
 */
export interface V1Search {
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Search
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Search
     */
    tags?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof V1Search
     */
    disabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1Search
     */
    deleted?: boolean;
    /**
     * 
     * @type {V1SearchSpec}
     * @memberof V1Search
     */
    spec?: V1SearchSpec;
    /**
     * 
     * @type {Date}
     * @memberof V1Search
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Search
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1SearchSpec
 */
export interface V1SearchSpec {
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    sort?: string;
    /**
     * 
     * @type {number}
     * @memberof V1SearchSpec
     */
    limit?: number;
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    groupby?: string;
    /**
     * 
     * @type {string}
     * @memberof V1SearchSpec
     */
    columns?: string;
}

/**
 * 
 * @export
 * @interface V1Service
 */
export interface V1Service {
    /**
     * 
     * @type {string}
     * @memberof V1Service
     */
    kind?: string;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1Service
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Service
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Service
     */
    volumes?: Array<V1Volume>;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1Service
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1Service
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1Service
     */
    container?: V1Container;
    /**
     * 
     * @type {Array<number>}
     * @memberof V1Service
     */
    ports?: Array<number>;
    /**
     * Rewrite path to remove polyaxon base url(i.e. /v1/services/namespace/owner/project/). Default is false, the service shoud handle a base url.
     * @type {boolean}
     * @memberof V1Service
     */
    rewritePath?: boolean;
}

/**
 * 
 * @export
 * @interface V1Spark
 */
export interface V1Spark {
    /**
     * 
     * @type {string}
     * @memberof V1Spark
     */
    kind?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Spark
     */
    connections?: Array<string>;
    /**
     * Volumes is a list of volumes that can be mounted.
     * @type {Array<V1Volume>}
     * @memberof V1Spark
     */
    volumes?: Array<V1Volume>;
    /**
     * Type tells the type of the Spark application.
     * @type {V1SparkType}
     * @memberof V1Spark
     */
    type?: V1SparkType;
    /**
     * Spark version is the version of Spark the application uses.
     * @type {string}
     * @memberof V1Spark
     */
    spark_version?: string;
    /**
     * Spark version is the version of Spark the application uses.
     * @type {string}
     * @memberof V1Spark
     */
    python_version?: string;
    /**
     * Mode is the deployment mode of the Spark application.
     * @type {SparkDeployMode}
     * @memberof V1Spark
     */
    deploy_mode?: SparkDeployMode;
    /**
     * MainClass is the fully-qualified main class of the Spark application. This only applies to Java/Scala Spark applications.
     * @type {string}
     * @memberof V1Spark
     */
    main_class?: string;
    /**
     * MainFile is the path to a bundled JAR, Python, or R file of the application.
     * @type {string}
     * @memberof V1Spark
     */
    main_application_file?: string;
    /**
     * Arguments is a list of arguments to be passed to the application.
     * @type {Array<string>}
     * @memberof V1Spark
     */
    arguments?: Array<string>;
    /**
     * HadoopConf carries user-specified Hadoop configuration properties as they would use the  the \"--conf\" option in spark-submit.  The SparkApplication controller automatically adds prefix \"spark.hadoop.\" to Hadoop configuration properties.
     * @type {{ [key: string]: string; }}
     * @memberof V1Spark
     */
    hadoop_conf?: { [key: string]: string; };
    /**
     * HadoopConf carries user-specified Hadoop configuration properties as they would use the  the \"--conf\" option in spark-submit.  The SparkApplication controller automatically adds prefix \"spark.hadoop.\" to Hadoop configuration properties.
     * @type {{ [key: string]: string; }}
     * @memberof V1Spark
     */
    spark_conf?: { [key: string]: string; };
    /**
     * SparkConfigMap carries the name of the ConfigMap containing Spark configuration files such as log4j.properties. The controller will add environment variable SPARK_CONF_DIR to the path where the ConfigMap is mounted to.
     * @type {string}
     * @memberof V1Spark
     */
    spark_config_map?: string;
    /**
     * HadoopConfigMap carries the name of the ConfigMap containing Hadoop configuration files such as core-site.xml. The controller will add environment variable HADOOP_CONF_DIR to the path where the ConfigMap is mounted to.
     * @type {string}
     * @memberof V1Spark
     */
    hadoop_config_map?: string;
    /**
     * 
     * @type {V1SparkReplica}
     * @memberof V1Spark
     */
    executor?: V1SparkReplica;
    /**
     * 
     * @type {V1SparkReplica}
     * @memberof V1Spark
     */
    driver?: V1SparkReplica;
}

/**
 * 
 * @export
 * @interface V1SparkReplica
 */
export interface V1SparkReplica {
    /**
     * 
     * @type {number}
     * @memberof V1SparkReplica
     */
    replicas?: number;
    /**
     * 
     * @type {V1Environment}
     * @memberof V1SparkReplica
     */
    environment?: V1Environment;
    /**
     * 
     * @type {Array<V1Init>}
     * @memberof V1SparkReplica
     */
    init?: Array<V1Init>;
    /**
     * 
     * @type {Array<V1Container>}
     * @memberof V1SparkReplica
     */
    sidecars?: Array<V1Container>;
    /**
     * 
     * @type {V1Container}
     * @memberof V1SparkReplica
     */
    container?: V1Container;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1SparkType {
    Java = <any> 'java',
    Scala = <any> 'scala',
    Python = <any> 'python',
    R = <any> 'r'
}

/**
 * 
 * @export
 * @interface V1Status
 */
export interface V1Status {
    /**
     * 
     * @type {string}
     * @memberof V1Status
     */
    uuid?: string;
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1Status
     */
    status?: V1Statuses;
    /**
     * 
     * @type {Array<V1StatusCondition>}
     * @memberof V1Status
     */
    status_conditions?: Array<V1StatusCondition>;
}

/**
 * 
 * @export
 * @interface V1StatusCond
 */
export interface V1StatusCond {
    /**
     * 
     * @type {string}
     * @memberof V1StatusCond
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCond
     */
    operation?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCond
     */
    trigger?: string;
}

/**
 * 
 * @export
 * @interface V1StatusCondition
 */
export interface V1StatusCondition {
    /**
     * 
     * @type {V1Statuses}
     * @memberof V1StatusCondition
     */
    type?: V1Statuses;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof V1StatusCondition
     */
    message?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_update_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1StatusCondition
     */
    last_transition_time?: Date;
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1Statuses {
    Created = <any> 'created',
    Resuming = <any> 'resuming',
    Warning = <any> 'warning',
    Unschedulable = <any> 'unschedulable',
    Queued = <any> 'queued',
    Scheduled = <any> 'scheduled',
    Starting = <any> 'starting',
    Running = <any> 'running',
    Succeeded = <any> 'succeeded',
    Failed = <any> 'failed',
    UpstreamFailed = <any> 'upstream_failed',
    Stopping = <any> 'stopping',
    Stopped = <any> 'stopped',
    Skipped = <any> 'skipped',
    Retrying = <any> 'retrying',
    Unknown = <any> 'unknown'
}

/**
 * 
 * @export
 * @interface V1TFJob
 */
export interface V1TFJob {
    /**
     * 
     * @type {string}
     * @memberof V1TFJob
     */
    kind?: string;
    /**
     * 
     * @type {V1CleanPodPolicy}
     * @memberof V1TFJob
     */
    cleanPodPolicy?: V1CleanPodPolicy;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1TFJob
     */
    chief?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1TFJob
     */
    ps?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1TFJob
     */
    worker?: V1KFReplica;
    /**
     * 
     * @type {V1KFReplica}
     * @memberof V1TFJob
     */
    evaluator?: V1KFReplica;
}

/**
 * 
 * @export
 * @interface V1Team
 */
export interface V1Team {
    /**
     * 
     * @type {string}
     * @memberof V1Team
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Team
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Team
     */
    projects?: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof V1Team
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1Team
     */
    updated_at?: Date;
}

/**
 * 
 * @export
 * @interface V1TeamMember
 */
export interface V1TeamMember {
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    user_email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof V1TeamMember
     */
    org_role?: string;
    /**
     * 
     * @type {Date}
     * @memberof V1TeamMember
     */
    created_at?: Date;
    /**
     * 
     * @type {Date}
     * @memberof V1TeamMember
     */
    updated_at?: Date;
}

/**
 * Termination specification, it defines how to handle failures, job runtime, and cleanup policy.
 * @export
 * @interface V1Termination
 */
export interface V1Termination {
    /**
     * 
     * @type {number}
     * @memberof V1Termination
     */
    max_retries?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Termination
     */
    ttl?: number;
    /**
     * 
     * @type {number}
     * @memberof V1Termination
     */
    timeout?: number;
}

/**
 * 
 * @export
 * @interface V1Toleration
 */
export interface V1Toleration {
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum V1TriggerPolicy {
    AllSucceeded = <any> 'all_succeeded',
    AllFailed = <any> 'all_failed',
    AllDone = <any> 'all_done',
    OneSucceeded = <any> 'one_succeeded',
    OneFailed = <any> 'one_failed',
    OneDone = <any> 'one_done'
}

/**
 * Early stopping with truncation stopping, this policy stops a percentage of all running runs at every evaluation.
 * @export
 * @interface V1TruncationStoppingPolicy
 */
export interface V1TruncationStoppingPolicy {
    /**
     * 
     * @type {string}
     * @memberof V1TruncationStoppingPolicy
     */
    kind?: string;
    /**
     * The percentage of runs to stop, at each evaluation interval. e.g. 1 - 99.
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    percent?: number;
    /**
     * Interval/Frequency for applying the policy.
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    evaluation_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    min_interval?: number;
    /**
     * 
     * @type {number}
     * @memberof V1TruncationStoppingPolicy
     */
    min_samples?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1TruncationStoppingPolicy
     */
    include_succeeded?: boolean;
}

/**
 * 
 * @export
 * @interface V1UriType
 */
export interface V1UriType {
    /**
     * 
     * @type {string}
     * @memberof V1UriType
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UriType
     */
    password?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1UriType
     */
    host?: boolean;
}

/**
 * 
 * @export
 * @interface V1UrlReference
 */
export interface V1UrlReference {
    /**
     * 
     * @type {string}
     * @memberof V1UrlReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof V1UrlReference
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface V1User
 */
export interface V1User {
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof V1User
     */
    role?: string;
}

/**
 * 
 * @export
 * @interface V1Uuids
 */
export interface V1Uuids {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1Uuids
     */
    uuids?: Array<string>;
}

/**
 * 
 * @export
 * @interface V1Version
 */
export interface V1Version {
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    min_version?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Version
     */
    latest_version?: string;
}

/**
 * 
 * @export
 * @interface V1Versions
 */
export interface V1Versions {
    /**
     * 
     * @type {string}
     * @memberof V1Versions
     */
    platform_version?: string;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    cli?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    platform?: V1Version;
    /**
     * 
     * @type {V1Version}
     * @memberof V1Versions
     */
    agent?: V1Version;
}

/**
 * 
 * @export
 * @interface V1Volume
 */
export interface V1Volume {
}

/**
 * 
 * @export
 * @interface V1WasbType
 */
export interface V1WasbType {
    /**
     * 
     * @type {string}
     * @memberof V1WasbType
     */
    container?: string;
    /**
     * 
     * @type {string}
     * @memberof V1WasbType
     */
    storage_account?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1WasbType
     */
    path?: boolean;
}

/**
 * 
 * @export
 * @interface V1WidgetSpec
 */
export interface V1WidgetSpec {
    /**
     * 
     * @type {string}
     * @memberof V1WidgetSpec
     */
    kind?: string;
    /**
     * 
     * @type {V1SearchSpec}
     * @memberof V1WidgetSpec
     */
    search?: V1SearchSpec;
    /**
     * 
     * @type {any}
     * @memberof V1WidgetSpec
     */
    meta?: any;
}


/**
 * AccessResourcesV1Api - fetch parameter creator
 * @export
 */
export const AccessResourcesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create access resource
         * @param {string} owner Owner of the namespace
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessResource(owner: string, body: V1AccessResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createAccessResource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AccessResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessResource(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteAccessResource.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessResource(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getAccessResource.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List access resource names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listAccessResourceNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List access resources
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listAccessResources.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchAccessResource.');
            }
            // verify required parameter 'access_resource_uuid' is not null or undefined
            if (access_resource_uuid === null || access_resource_uuid === undefined) {
                throw new RequiredError('access_resource_uuid','Required parameter access_resource_uuid was null or undefined when calling patchAccessResource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/{access_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"access_resource.uuid"}}`, encodeURIComponent(String(access_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AccessResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateAccessResource.');
            }
            // verify required parameter 'access_resource_uuid' is not null or undefined
            if (access_resource_uuid === null || access_resource_uuid === undefined) {
                throw new RequiredError('access_resource_uuid','Required parameter access_resource_uuid was null or undefined when calling updateAccessResource.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAccessResource.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/access_resources/{access_resource.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"access_resource.uuid"}}`, encodeURIComponent(String(access_resource_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AccessResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessResourcesV1Api - functional programming interface
 * @export
 */
export const AccessResourcesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create access resource
         * @param {string} owner Owner of the namespace
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessResource(owner: string, body: V1AccessResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AccessResource> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).createAccessResource(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessResource(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).deleteAccessResource(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessResource(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AccessResource> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).getAccessResource(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List access resource names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAccessResourcesResponse> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).listAccessResourceNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List access resources
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAccessResourcesResponse> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).listAccessResources(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AccessResource> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).patchAccessResource(owner, access_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AccessResource> {
            const localVarFetchArgs = AccessResourcesV1ApiFetchParamCreator(configuration).updateAccessResource(owner, access_resource_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccessResourcesV1Api - factory interface
 * @export
 */
export const AccessResourcesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create access resource
         * @param {string} owner Owner of the namespace
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessResource(owner: string, body: V1AccessResource, options?: any) {
            return AccessResourcesV1ApiFp(configuration).createAccessResource(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccessResource(owner: string, uuid: string, options?: any) {
            return AccessResourcesV1ApiFp(configuration).deleteAccessResource(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get access resource
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessResource(owner: string, uuid: string, options?: any) {
            return AccessResourcesV1ApiFp(configuration).getAccessResource(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List access resource names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AccessResourcesV1ApiFp(configuration).listAccessResourceNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List access resources
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AccessResourcesV1ApiFp(configuration).listAccessResources(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any) {
            return AccessResourcesV1ApiFp(configuration).patchAccessResource(owner, access_resource_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update access resource
         * @param {string} owner Owner of the namespace
         * @param {string} access_resource_uuid UUID
         * @param {V1AccessResource} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any) {
            return AccessResourcesV1ApiFp(configuration).updateAccessResource(owner, access_resource_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * AccessResourcesV1Api - object-oriented interface
 * @export
 * @class AccessResourcesV1Api
 * @extends {BaseAPI}
 */
export class AccessResourcesV1Api extends BaseAPI {
    /**
     * 
     * @summary Create access resource
     * @param {string} owner Owner of the namespace
     * @param {V1AccessResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public createAccessResource(owner: string, body: V1AccessResource, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).createAccessResource(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete access resource
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public deleteAccessResource(owner: string, uuid: string, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).deleteAccessResource(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get access resource
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public getAccessResource(owner: string, uuid: string, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).getAccessResource(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List access resource names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public listAccessResourceNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).listAccessResourceNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List access resources
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public listAccessResources(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).listAccessResources(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch access resource
     * @param {string} owner Owner of the namespace
     * @param {string} access_resource_uuid UUID
     * @param {V1AccessResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public patchAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).patchAccessResource(owner, access_resource_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update access resource
     * @param {string} owner Owner of the namespace
     * @param {string} access_resource_uuid UUID
     * @param {V1AccessResource} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessResourcesV1Api
     */
    public updateAccessResource(owner: string, access_resource_uuid: string, body: V1AccessResource, options?: any) {
        return AccessResourcesV1ApiFp(this.configuration).updateAccessResource(owner, access_resource_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * AgentsV1Api - fetch parameter creator
 * @export
 */
export const AgentsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create agent
         * @param {string} owner Owner of the namespace
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(owner: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1AgentStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentStatus(owner: string, uuid: string, body: V1AgentStatusBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createAgentStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createAgentStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAgentStatus.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1AgentStatusBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete agent
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteAgent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get agent
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getAgent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get State (queues/runs)
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentState(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getAgentState.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getAgentState.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}/state`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get agent status
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentStatuses(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getAgentStatuses.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getAgentStatuses.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List agents names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listAgentNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List agents
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listAgents.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent(owner: string, agent_uuid: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchAgent.');
            }
            // verify required parameter 'agent_uuid' is not null or undefined
            if (agent_uuid === null || agent_uuid === undefined) {
                throw new RequiredError('agent_uuid','Required parameter agent_uuid was null or undefined when calling patchAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent.uuid"}}`, encodeURIComponent(String(agent_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAgent(owner: string, agent_uuid: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling syncAgent.');
            }
            // verify required parameter 'agent_uuid' is not null or undefined
            if (agent_uuid === null || agent_uuid === undefined) {
                throw new RequiredError('agent_uuid','Required parameter agent_uuid was null or undefined when calling syncAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling syncAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent.uuid}/sync`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent.uuid"}}`, encodeURIComponent(String(agent_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent(owner: string, agent_uuid: string, body: V1Agent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateAgent.');
            }
            // verify required parameter 'agent_uuid' is not null or undefined
            if (agent_uuid === null || agent_uuid === undefined) {
                throw new RequiredError('agent_uuid','Required parameter agent_uuid was null or undefined when calling updateAgent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAgent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent.uuid"}}`, encodeURIComponent(String(agent_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Agent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsV1Api - functional programming interface
 * @export
 */
export const AgentsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create agent
         * @param {string} owner Owner of the namespace
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(owner: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).createAgent(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1AgentStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentStatus(owner: string, uuid: string, body: V1AgentStatusBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).createAgentStatus(owner, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete agent
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).deleteAgent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get agent
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).getAgent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get State (queues/runs)
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentState(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1AgentStateResponse> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).getAgentState(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get agent status
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentStatuses(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).getAgentStatuses(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List agents names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAgentsResponse> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).listAgentNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List agents
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListAgentsResponse> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).listAgents(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).patchAgent(owner, agent_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Sync agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).syncAgent(owner, agent_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = AgentsV1ApiFetchParamCreator(configuration).updateAgent(owner, agent_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AgentsV1Api - factory interface
 * @export
 */
export const AgentsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create agent
         * @param {string} owner Owner of the namespace
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(owner: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).createAgent(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1AgentStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentStatus(owner: string, uuid: string, body: V1AgentStatusBodyRequest, options?: any) {
            return AgentsV1ApiFp(configuration).createAgentStatus(owner, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete agent
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).deleteAgent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get agent
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).getAgent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get State (queues/runs)
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentState(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).getAgentState(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get agent status
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentStatuses(owner: string, uuid: string, options?: any) {
            return AgentsV1ApiFp(configuration).getAgentStatuses(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List agents names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AgentsV1ApiFp(configuration).listAgentNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List agents
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return AgentsV1ApiFp(configuration).listAgents(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).patchAgent(owner, agent_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sync agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).syncAgent(owner, agent_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update agent
         * @param {string} owner Owner of the namespace
         * @param {string} agent_uuid UUID
         * @param {V1Agent} body Agent body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
            return AgentsV1ApiFp(configuration).updateAgent(owner, agent_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * AgentsV1Api - object-oriented interface
 * @export
 * @class AgentsV1Api
 * @extends {BaseAPI}
 */
export class AgentsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create agent
     * @param {string} owner Owner of the namespace
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public createAgent(owner: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).createAgent(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run status
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1AgentStatusBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public createAgentStatus(owner: string, uuid: string, body: V1AgentStatusBodyRequest, options?: any) {
        return AgentsV1ApiFp(this.configuration).createAgentStatus(owner, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete agent
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public deleteAgent(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).deleteAgent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get agent
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public getAgent(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).getAgent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get State (queues/runs)
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public getAgentState(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).getAgentState(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get agent status
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public getAgentStatuses(owner: string, uuid: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).getAgentStatuses(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List agents names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public listAgentNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).listAgentNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List agents
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public listAgents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return AgentsV1ApiFp(this.configuration).listAgents(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch agent
     * @param {string} owner Owner of the namespace
     * @param {string} agent_uuid UUID
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public patchAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).patchAgent(owner, agent_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Sync agent
     * @param {string} owner Owner of the namespace
     * @param {string} agent_uuid UUID
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public syncAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).syncAgent(owner, agent_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update agent
     * @param {string} owner Owner of the namespace
     * @param {string} agent_uuid UUID
     * @param {V1Agent} body Agent body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsV1Api
     */
    public updateAgent(owner: string, agent_uuid: string, body: V1Agent, options?: any) {
        return AgentsV1ApiFp(this.configuration).updateAgent(owner, agent_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ArtifactsStoresV1Api - fetch parameter creator
 * @export
 */
export const ArtifactsStoresV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadArtifact.');
            }
            const localVarPath = `/api/v1/catalogs/{owner}/artifacts/{uuid}/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - functional programming interface
 * @export
 */
export const ArtifactsStoresV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArtifactsStoresV1ApiFetchParamCreator(configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArtifactsStoresV1Api - factory interface
 * @export
 */
export const ArtifactsStoresV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Upload artifact to a store
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return ArtifactsStoresV1ApiFp(configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * ArtifactsStoresV1Api - object-oriented interface
 * @export
 * @class ArtifactsStoresV1Api
 * @extends {BaseAPI}
 */
export class ArtifactsStoresV1Api extends BaseAPI {
    /**
     * 
     * @summary Upload artifact to a store
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsStoresV1Api
     */
    public uploadArtifact(owner: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return ArtifactsStoresV1ApiFp(this.configuration).uploadArtifact(owner, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthV1Api - fetch parameter creator
 * @export
 */
export const AuthV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/api/v1/users/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1CredsBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthV1Api - functional programming interface
 * @export
 */
export const AuthV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = AuthV1ApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthV1Api - factory interface
 * @export
 */
export const AuthV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Login
         * @param {V1CredsBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: V1CredsBodyRequest, options?: any) {
            return AuthV1ApiFp(configuration).login(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthV1Api - object-oriented interface
 * @export
 * @class AuthV1Api
 * @extends {BaseAPI}
 */
export class AuthV1Api extends BaseAPI {
    /**
     * 
     * @summary Login
     * @param {V1CredsBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthV1Api
     */
    public login(body: V1CredsBodyRequest, options?: any) {
        return AuthV1ApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ConnectionsV1Api - fetch parameter creator
 * @export
 */
export const ConnectionsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create connection
         * @param {string} owner Owner of the namespace
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(owner: string, body: V1ConnectionResponse, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createConnection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ConnectionResponse" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteConnection.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getConnection.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List connections names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listConnectionNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List connections
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listConnections.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchConnection.');
            }
            // verify required parameter 'connection_uuid' is not null or undefined
            if (connection_uuid === null || connection_uuid === undefined) {
                throw new RequiredError('connection_uuid','Required parameter connection_uuid was null or undefined when calling patchConnection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{connection.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"connection.uuid"}}`, encodeURIComponent(String(connection_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ConnectionResponse" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateConnection.');
            }
            // verify required parameter 'connection_uuid' is not null or undefined
            if (connection_uuid === null || connection_uuid === undefined) {
                throw new RequiredError('connection_uuid','Required parameter connection_uuid was null or undefined when calling updateConnection.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateConnection.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/connections/{connection.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"connection.uuid"}}`, encodeURIComponent(String(connection_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ConnectionResponse" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsV1Api - functional programming interface
 * @export
 */
export const ConnectionsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create connection
         * @param {string} owner Owner of the namespace
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(owner: string, body: V1ConnectionResponse, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConnectionResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).createConnection(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).deleteConnection(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConnectionResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).getConnection(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List connections names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListConnectionsResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).listConnectionNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List connections
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListConnectionsResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).listConnections(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConnectionResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).patchConnection(owner, connection_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ConnectionResponse> {
            const localVarFetchArgs = ConnectionsV1ApiFetchParamCreator(configuration).updateConnection(owner, connection_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConnectionsV1Api - factory interface
 * @export
 */
export const ConnectionsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create connection
         * @param {string} owner Owner of the namespace
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(owner: string, body: V1ConnectionResponse, options?: any) {
            return ConnectionsV1ApiFp(configuration).createConnection(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(owner: string, uuid: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).deleteConnection(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get connection
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(owner: string, uuid: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).getConnection(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List connections names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).listConnectionNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List connections
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ConnectionsV1ApiFp(configuration).listConnections(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any) {
            return ConnectionsV1ApiFp(configuration).patchConnection(owner, connection_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update connection
         * @param {string} owner Owner of the namespace
         * @param {string} connection_uuid UUID
         * @param {V1ConnectionResponse} body Connection body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any) {
            return ConnectionsV1ApiFp(configuration).updateConnection(owner, connection_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ConnectionsV1Api - object-oriented interface
 * @export
 * @class ConnectionsV1Api
 * @extends {BaseAPI}
 */
export class ConnectionsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create connection
     * @param {string} owner Owner of the namespace
     * @param {V1ConnectionResponse} body Connection body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public createConnection(owner: string, body: V1ConnectionResponse, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).createConnection(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete connection
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public deleteConnection(owner: string, uuid: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).deleteConnection(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get connection
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public getConnection(owner: string, uuid: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).getConnection(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List connections names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public listConnectionNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).listConnectionNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List connections
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public listConnections(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).listConnections(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch connection
     * @param {string} owner Owner of the namespace
     * @param {string} connection_uuid UUID
     * @param {V1ConnectionResponse} body Connection body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public patchConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).patchConnection(owner, connection_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update connection
     * @param {string} owner Owner of the namespace
     * @param {string} connection_uuid UUID
     * @param {V1ConnectionResponse} body Connection body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsV1Api
     */
    public updateConnection(owner: string, connection_uuid: string, body: V1ConnectionResponse, options?: any) {
        return ConnectionsV1ApiFp(this.configuration).updateConnection(owner, connection_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * DashboardsV1Api - fetch parameter creator
 * @export
 */
export const DashboardsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {string} owner Owner of the namespace
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard(owner: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List dashboard names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listDashboardNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List dashboards
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listDashboards.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling patchDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling updateDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateDashboard.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsV1Api - functional programming interface
 * @export
 */
export const DashboardsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {string} owner Owner of the namespace
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard(owner: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).createDashboard(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).deleteDashboard(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).getDashboard(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List dashboard names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).listDashboardNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List dashboards
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).listDashboards(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).patchDashboard(owner, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = DashboardsV1ApiFetchParamCreator(configuration).updateDashboard(owner, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DashboardsV1Api - factory interface
 * @export
 */
export const DashboardsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create dashboard
         * @param {string} owner Owner of the namespace
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboard(owner: string, body: V1Dashboard, options?: any) {
            return DashboardsV1ApiFp(configuration).createDashboard(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboard(owner: string, uuid: string, options?: any) {
            return DashboardsV1ApiFp(configuration).deleteDashboard(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboard(owner: string, uuid: string, options?: any) {
            return DashboardsV1ApiFp(configuration).getDashboard(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List dashboard names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return DashboardsV1ApiFp(configuration).listDashboardNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List dashboards
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return DashboardsV1ApiFp(configuration).listDashboards(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return DashboardsV1ApiFp(configuration).patchDashboard(owner, dashboard_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return DashboardsV1ApiFp(configuration).updateDashboard(owner, dashboard_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * DashboardsV1Api - object-oriented interface
 * @export
 * @class DashboardsV1Api
 * @extends {BaseAPI}
 */
export class DashboardsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create dashboard
     * @param {string} owner Owner of the namespace
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public createDashboard(owner: string, body: V1Dashboard, options?: any) {
        return DashboardsV1ApiFp(this.configuration).createDashboard(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public deleteDashboard(owner: string, uuid: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).deleteDashboard(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public getDashboard(owner: string, uuid: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).getDashboard(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List dashboard names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public listDashboardNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).listDashboardNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List dashboards
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return DashboardsV1ApiFp(this.configuration).listDashboards(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public patchDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return DashboardsV1ApiFp(this.configuration).patchDashboard(owner, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsV1Api
     */
    public updateDashboard(owner: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return DashboardsV1ApiFp(this.configuration).updateDashboard(owner, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * HubComponentsV1Api - fetch parameter creator
 * @export
 */
export const HubComponentsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create hub component
         * @param {string} owner Owner of the namespace
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHubComponent(owner: string, body: V1HubComponent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createHubComponent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubComponent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHubComponent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteHubComponent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubComponent(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getHubComponent.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List hub component names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubComponebtNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listHubComponebtNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List hub components
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubComponents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listHubComponents.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch hub component
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchHubComponent.');
            }
            // verify required parameter 'component_uuid' is not null or undefined
            if (component_uuid === null || component_uuid === undefined) {
                throw new RequiredError('component_uuid','Required parameter component_uuid was null or undefined when calling patchHubComponent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/{component.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"component.uuid"}}`, encodeURIComponent(String(component_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubComponent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update hub component
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateHubComponent.');
            }
            // verify required parameter 'component_uuid' is not null or undefined
            if (component_uuid === null || component_uuid === undefined) {
                throw new RequiredError('component_uuid','Required parameter component_uuid was null or undefined when calling updateHubComponent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateHubComponent.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/components/{component.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"component.uuid"}}`, encodeURIComponent(String(component_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubComponent" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HubComponentsV1Api - functional programming interface
 * @export
 */
export const HubComponentsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create hub component
         * @param {string} owner Owner of the namespace
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHubComponent(owner: string, body: V1HubComponent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubComponent> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).createHubComponent(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHubComponent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).deleteHubComponent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubComponent(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubComponent> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).getHubComponent(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List hub component names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubComponebtNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHubComponentsResponse> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).listHubComponebtNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List hub components
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubComponents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHubComponentsResponse> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).listHubComponents(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch hub component
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubComponent> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).patchHubComponent(owner, component_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update hub component
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubComponent> {
            const localVarFetchArgs = HubComponentsV1ApiFetchParamCreator(configuration).updateHubComponent(owner, component_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HubComponentsV1Api - factory interface
 * @export
 */
export const HubComponentsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create hub component
         * @param {string} owner Owner of the namespace
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHubComponent(owner: string, body: V1HubComponent, options?: any) {
            return HubComponentsV1ApiFp(configuration).createHubComponent(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHubComponent(owner: string, uuid: string, options?: any) {
            return HubComponentsV1ApiFp(configuration).deleteHubComponent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get hub component
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubComponent(owner: string, uuid: string, options?: any) {
            return HubComponentsV1ApiFp(configuration).getHubComponent(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List hub component names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubComponebtNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return HubComponentsV1ApiFp(configuration).listHubComponebtNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List hub components
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubComponents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return HubComponentsV1ApiFp(configuration).listHubComponents(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch hub component
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any) {
            return HubComponentsV1ApiFp(configuration).patchHubComponent(owner, component_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update hub component
         * @param {string} owner Owner of the namespace
         * @param {string} component_uuid UUID
         * @param {V1HubComponent} body Component body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any) {
            return HubComponentsV1ApiFp(configuration).updateHubComponent(owner, component_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * HubComponentsV1Api - object-oriented interface
 * @export
 * @class HubComponentsV1Api
 * @extends {BaseAPI}
 */
export class HubComponentsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create hub component
     * @param {string} owner Owner of the namespace
     * @param {V1HubComponent} body Component body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public createHubComponent(owner: string, body: V1HubComponent, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).createHubComponent(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete hub component
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public deleteHubComponent(owner: string, uuid: string, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).deleteHubComponent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get hub component
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public getHubComponent(owner: string, uuid: string, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).getHubComponent(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List hub component names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public listHubComponebtNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).listHubComponebtNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List hub components
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public listHubComponents(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).listHubComponents(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch hub component
     * @param {string} owner Owner of the namespace
     * @param {string} component_uuid UUID
     * @param {V1HubComponent} body Component body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public patchHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).patchHubComponent(owner, component_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update hub component
     * @param {string} owner Owner of the namespace
     * @param {string} component_uuid UUID
     * @param {V1HubComponent} body Component body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubComponentsV1Api
     */
    public updateHubComponent(owner: string, component_uuid: string, body: V1HubComponent, options?: any) {
        return HubComponentsV1ApiFp(this.configuration).updateHubComponent(owner, component_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * HubModelsV1Api - fetch parameter creator
 * @export
 */
export const HubModelsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create hub model
         * @param {string} owner Owner of the namespace
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHubModel(owner: string, body: V1HubModel, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createHubModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHubModel(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteHubModel.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubModel(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getHubModel.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List hub model names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubModelNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listHubModelNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List hub models
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubModels(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listHubModels.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch hub model
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchHubModel(owner: string, model_uuid: string, body: V1HubModel, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchHubModel.');
            }
            // verify required parameter 'model_uuid' is not null or undefined
            if (model_uuid === null || model_uuid === undefined) {
                throw new RequiredError('model_uuid','Required parameter model_uuid was null or undefined when calling patchHubModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/{model.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"model.uuid"}}`, encodeURIComponent(String(model_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update hub model
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHubModel(owner: string, model_uuid: string, body: V1HubModel, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateHubModel.');
            }
            // verify required parameter 'model_uuid' is not null or undefined
            if (model_uuid === null || model_uuid === undefined) {
                throw new RequiredError('model_uuid','Required parameter model_uuid was null or undefined when calling updateHubModel.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateHubModel.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/models/{model.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"model.uuid"}}`, encodeURIComponent(String(model_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1HubModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HubModelsV1Api - functional programming interface
 * @export
 */
export const HubModelsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create hub model
         * @param {string} owner Owner of the namespace
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHubModel(owner: string, body: V1HubModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubModel> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).createHubModel(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHubModel(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).deleteHubModel(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubModel(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubModel> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).getHubModel(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List hub model names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubModelNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHubModelsResponse> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).listHubModelNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List hub models
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubModels(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListHubModelsResponse> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).listHubModels(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch hub model
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubModel> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).patchHubModel(owner, model_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update hub model
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1HubModel> {
            const localVarFetchArgs = HubModelsV1ApiFetchParamCreator(configuration).updateHubModel(owner, model_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HubModelsV1Api - factory interface
 * @export
 */
export const HubModelsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create hub model
         * @param {string} owner Owner of the namespace
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHubModel(owner: string, body: V1HubModel, options?: any) {
            return HubModelsV1ApiFp(configuration).createHubModel(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHubModel(owner: string, uuid: string, options?: any) {
            return HubModelsV1ApiFp(configuration).deleteHubModel(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get hub model
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHubModel(owner: string, uuid: string, options?: any) {
            return HubModelsV1ApiFp(configuration).getHubModel(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List hub model names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubModelNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return HubModelsV1ApiFp(configuration).listHubModelNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List hub models
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listHubModels(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return HubModelsV1ApiFp(configuration).listHubModels(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch hub model
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any) {
            return HubModelsV1ApiFp(configuration).patchHubModel(owner, model_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update hub model
         * @param {string} owner Owner of the namespace
         * @param {string} model_uuid UUID
         * @param {V1HubModel} body Model body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any) {
            return HubModelsV1ApiFp(configuration).updateHubModel(owner, model_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * HubModelsV1Api - object-oriented interface
 * @export
 * @class HubModelsV1Api
 * @extends {BaseAPI}
 */
export class HubModelsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create hub model
     * @param {string} owner Owner of the namespace
     * @param {V1HubModel} body Model body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public createHubModel(owner: string, body: V1HubModel, options?: any) {
        return HubModelsV1ApiFp(this.configuration).createHubModel(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete hub model
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public deleteHubModel(owner: string, uuid: string, options?: any) {
        return HubModelsV1ApiFp(this.configuration).deleteHubModel(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get hub model
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public getHubModel(owner: string, uuid: string, options?: any) {
        return HubModelsV1ApiFp(this.configuration).getHubModel(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List hub model names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public listHubModelNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return HubModelsV1ApiFp(this.configuration).listHubModelNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List hub models
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public listHubModels(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return HubModelsV1ApiFp(this.configuration).listHubModels(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch hub model
     * @param {string} owner Owner of the namespace
     * @param {string} model_uuid UUID
     * @param {V1HubModel} body Model body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public patchHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any) {
        return HubModelsV1ApiFp(this.configuration).patchHubModel(owner, model_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update hub model
     * @param {string} owner Owner of the namespace
     * @param {string} model_uuid UUID
     * @param {V1HubModel} body Model body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HubModelsV1Api
     */
    public updateHubModel(owner: string, model_uuid: string, body: V1HubModel, options?: any) {
        return HubModelsV1ApiFp(this.configuration).updateHubModel(owner, model_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationsV1Api - fetch parameter creator
 * @export
 */
export const OrganizationsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create organization
         * @param {V1Organization} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(body: V1Organization, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrganization.');
            }
            const localVarPath = `/api/v1/orgs/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create organization member
         * @param {string} owner Owner of the namespace
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationMember(owner: string, body: V1OrganizationMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createOrganizationMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OrganizationMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationMember(owner: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteOrganizationMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(owner: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMember(owner: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getOrganizationMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listOrganizationMembers.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organizations names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationNames(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/orgs/names`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/orgs/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch organization
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganization(owner: string, body: V1Organization, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchOrganization.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch organization member
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchOrganizationMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling patchOrganizationMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OrganizationMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(owner: string, body: V1Organization, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateOrganization.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateOrganization.');
            }
            const localVarPath = `/api/v1/orgs/{owner}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Organization" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization member
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateOrganizationMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling updateOrganizationMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateOrganizationMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OrganizationMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsV1Api - functional programming interface
 * @export
 */
export const OrganizationsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create organization
         * @param {V1Organization} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(body: V1Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).createOrganization(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create organization member
         * @param {string} owner Owner of the namespace
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationMember(owner: string, body: V1OrganizationMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).createOrganizationMember(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete organization
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).deleteOrganization(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationMember(owner: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).deleteOrganizationMember(owner, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get organization
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(owner: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).getOrganization(owner, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMember(owner: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).getOrganizationMember(owner, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListOrganizationMembersResponse> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).listOrganizationMembers(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List organizations names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationNames(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListOrganizationsResponse> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).listOrganizationNames(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListOrganizationsResponse> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).listOrganizations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch organization
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganization(owner: string, body: V1Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).patchOrganization(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch organization member
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).patchOrganizationMember(owner, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update organization
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(owner: string, body: V1Organization, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Organization> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).updateOrganization(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update organization member
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1OrganizationMember> {
            const localVarFetchArgs = OrganizationsV1ApiFetchParamCreator(configuration).updateOrganizationMember(owner, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationsV1Api - factory interface
 * @export
 */
export const OrganizationsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create organization
         * @param {V1Organization} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(body: V1Organization, options?: any) {
            return OrganizationsV1ApiFp(configuration).createOrganization(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create organization member
         * @param {string} owner Owner of the namespace
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationMember(owner: string, body: V1OrganizationMember, options?: any) {
            return OrganizationsV1ApiFp(configuration).createOrganizationMember(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete organization
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(owner: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).deleteOrganization(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationMember(owner: string, user: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).deleteOrganizationMember(owner, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get organization
         * @param {string} owner Owner of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(owner: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).getOrganization(owner, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get organization member details
         * @param {string} owner Owner of the namespace
         * @param {string} user Memeber under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationMember(owner: string, user: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).getOrganizationMember(owner, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get organization members
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return OrganizationsV1ApiFp(configuration).listOrganizationMembers(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List organizations names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationNames(options?: any) {
            return OrganizationsV1ApiFp(configuration).listOrganizationNames(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options?: any) {
            return OrganizationsV1ApiFp(configuration).listOrganizations(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch organization
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganization(owner: string, body: V1Organization, options?: any) {
            return OrganizationsV1ApiFp(configuration).patchOrganization(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch organization member
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
            return OrganizationsV1ApiFp(configuration).patchOrganizationMember(owner, member_user, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update organization
         * @param {string} owner Owner of the namespace
         * @param {V1Organization} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(owner: string, body: V1Organization, options?: any) {
            return OrganizationsV1ApiFp(configuration).updateOrganization(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update organization member
         * @param {string} owner Owner of the namespace
         * @param {string} member_user User
         * @param {V1OrganizationMember} body Organization body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
            return OrganizationsV1ApiFp(configuration).updateOrganizationMember(owner, member_user, body, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationsV1Api - object-oriented interface
 * @export
 * @class OrganizationsV1Api
 * @extends {BaseAPI}
 */
export class OrganizationsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create organization
     * @param {V1Organization} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public createOrganization(body: V1Organization, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).createOrganization(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create organization member
     * @param {string} owner Owner of the namespace
     * @param {V1OrganizationMember} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public createOrganizationMember(owner: string, body: V1OrganizationMember, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).createOrganizationMember(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete organization
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public deleteOrganization(owner: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).deleteOrganization(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete organization member details
     * @param {string} owner Owner of the namespace
     * @param {string} user Memeber under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public deleteOrganizationMember(owner: string, user: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).deleteOrganizationMember(owner, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get organization
     * @param {string} owner Owner of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public getOrganization(owner: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).getOrganization(owner, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get organization member details
     * @param {string} owner Owner of the namespace
     * @param {string} user Memeber under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public getOrganizationMember(owner: string, user: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).getOrganizationMember(owner, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get organization members
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public listOrganizationMembers(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).listOrganizationMembers(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List organizations names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public listOrganizationNames(options?: any) {
        return OrganizationsV1ApiFp(this.configuration).listOrganizationNames(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public listOrganizations(options?: any) {
        return OrganizationsV1ApiFp(this.configuration).listOrganizations(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch organization
     * @param {string} owner Owner of the namespace
     * @param {V1Organization} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public patchOrganization(owner: string, body: V1Organization, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).patchOrganization(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch organization member
     * @param {string} owner Owner of the namespace
     * @param {string} member_user User
     * @param {V1OrganizationMember} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public patchOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).patchOrganizationMember(owner, member_user, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update organization
     * @param {string} owner Owner of the namespace
     * @param {V1Organization} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public updateOrganization(owner: string, body: V1Organization, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).updateOrganization(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update organization member
     * @param {string} owner Owner of the namespace
     * @param {string} member_user User
     * @param {V1OrganizationMember} body Organization body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsV1Api
     */
    public updateOrganizationMember(owner: string, member_user: string, body: V1OrganizationMember, options?: any) {
        return OrganizationsV1ApiFp(this.configuration).updateOrganizationMember(owner, member_user, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectDashboardsV1Api - fetch parameter creator
 * @export
 */
export const ProjectDashboardsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectDashboard(owner: string, project: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createProjectDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDashboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteProjectDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDashboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProjectDashboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectDashboardNames.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listProjectDashboardNames.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project dashboards
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectDashboards.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listProjectDashboards.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchProjectDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling patchProjectDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Promote project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling promoteProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling promoteProjectDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling promoteProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{dashboard.uuid}/promote`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProjectDashboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateProjectDashboard.');
            }
            // verify required parameter 'dashboard_uuid' is not null or undefined
            if (dashboard_uuid === null || dashboard_uuid === undefined) {
                throw new RequiredError('dashboard_uuid','Required parameter dashboard_uuid was null or undefined when calling updateProjectDashboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProjectDashboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/dashboards/{dashboard.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"dashboard.uuid"}}`, encodeURIComponent(String(dashboard_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Dashboard" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectDashboardsV1Api - functional programming interface
 * @export
 */
export const ProjectDashboardsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectDashboard(owner: string, project: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).createProjectDashboard(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDashboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).deleteProjectDashboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDashboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).getProjectDashboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).listProjectDashboardNames(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project dashboards
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListDashboardsResponse> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).listProjectDashboards(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).patchProjectDashboard(owner, project, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Promote project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).promoteProjectDashboard(owner, project, dashboard_uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Dashboard> {
            const localVarFetchArgs = ProjectDashboardsV1ApiFetchParamCreator(configuration).updateProjectDashboard(owner, project, dashboard_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectDashboardsV1Api - factory interface
 * @export
 */
export const ProjectDashboardsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectDashboard(owner: string, project: string, body: V1Dashboard, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).createProjectDashboard(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).deleteProjectDashboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).getProjectDashboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).listProjectDashboardNames(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project dashboards
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).listProjectDashboards(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).patchProjectDashboard(owner, project, dashboard_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Promote project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).promoteProjectDashboard(owner, project, dashboard_uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project dashboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} dashboard_uuid UUID
         * @param {V1Dashboard} body Dashboard body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
            return ProjectDashboardsV1ApiFp(configuration).updateProjectDashboard(owner, project, dashboard_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectDashboardsV1Api - object-oriented interface
 * @export
 * @class ProjectDashboardsV1Api
 * @extends {BaseAPI}
 */
export class ProjectDashboardsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public createProjectDashboard(owner: string, project: string, body: V1Dashboard, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).createProjectDashboard(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public deleteProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).deleteProjectDashboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public getProjectDashboard(owner: string, project: string, uuid: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).getProjectDashboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public listProjectDashboardNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).listProjectDashboardNames(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project dashboards
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public listProjectDashboards(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).listProjectDashboards(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public patchProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).patchProjectDashboard(owner, project, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Promote project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} dashboard_uuid UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public promoteProjectDashboard(owner: string, project: string, dashboard_uuid: string, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).promoteProjectDashboard(owner, project, dashboard_uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project dashboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} dashboard_uuid UUID
     * @param {V1Dashboard} body Dashboard body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectDashboardsV1Api
     */
    public updateProjectDashboard(owner: string, project: string, dashboard_uuid: string, body: V1Dashboard, options?: any) {
        return ProjectDashboardsV1ApiFp(this.configuration).updateProjectDashboard(owner, project, dashboard_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectSearchesV1Api - fetch parameter creator
 * @export
 */
export const ProjectSearchesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSearch(owner: string, project: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createProjectSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteProjectSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProjectSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project search names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectSearchNames.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listProjectSearchNames.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project searches
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectSearches.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listProjectSearches.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchProjectSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling patchProjectSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Promote project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectSearch(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling promoteProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling promoteProjectSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling promoteProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{uuid}/promote`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProjectSearch.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateProjectSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling updateProjectSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProjectSearch.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSearchesV1Api - functional programming interface
 * @export
 */
export const ProjectSearchesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSearch(owner: string, project: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).createProjectSearch(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).deleteProjectSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).getProjectSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project search names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).listProjectSearchNames(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project searches
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).listProjectSearches(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).patchProjectSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Promote project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectSearch(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).promoteProjectSearch(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = ProjectSearchesV1ApiFetchParamCreator(configuration).updateProjectSearch(owner, project, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectSearchesV1Api - factory interface
 * @export
 */
export const ProjectSearchesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectSearch(owner: string, project: string, body: V1Search, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).createProjectSearch(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).deleteProjectSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSearch(owner: string, project: string, uuid: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).getProjectSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project search names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).listProjectSearchNames(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project searches
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).listProjectSearches(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).patchProjectSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Promote project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).promoteProjectSearch(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project search
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
            return ProjectSearchesV1ApiFp(configuration).updateProjectSearch(owner, project, search_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectSearchesV1Api - object-oriented interface
 * @export
 * @class ProjectSearchesV1Api
 * @extends {BaseAPI}
 */
export class ProjectSearchesV1Api extends BaseAPI {
    /**
     * 
     * @summary Create project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public createProjectSearch(owner: string, project: string, body: V1Search, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).createProjectSearch(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public deleteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).deleteProjectSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public getProjectSearch(owner: string, project: string, uuid: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).getProjectSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project search names
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public listProjectSearchNames(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).listProjectSearchNames(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project searches
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public listProjectSearches(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).listProjectSearches(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public patchProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).patchProjectSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Promote project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public promoteProjectSearch(owner: string, project: string, uuid: string, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).promoteProjectSearch(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project search
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSearchesV1Api
     */
    public updateProjectSearch(owner: string, project: string, search_uuid: string, body: V1Search, options?: any) {
        return ProjectSearchesV1ApiFp(this.configuration).updateProjectSearch(owner, project, search_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectsV1Api - fetch parameter creator
 * @export
 */
export const ProjectsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new project
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProject.');
            }
            const localVarPath = `/api/v1/{owner}/projects/create`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disbale project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling disableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling disableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling enableProjectCI.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling enableProjectCI.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/ci`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchProjectTeams(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling fetchProjectTeams.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling fetchProjectTeams.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettings(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getProjectSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getProjectSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listArchivedProjects.');
            }
            const localVarPath = `/api/v1/archives/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listBookmarkedProjects.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/projects`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List project names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjectNames.');
            }
            const localVarPath = `/api/v1/{owner}/projects/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List projects
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listProjects.');
            }
            const localVarPath = `/api/v1/{owner}/projects/list`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling patchProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProjectSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchProjectSettings.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProjectSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchProjectTeams.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchProjectTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchProjectTeams.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectTeams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unbookmarkProject.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unbookmarkProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProject.');
            }
            // verify required parameter 'project_name' is not null or undefined
            if (project_name === null || project_name === undefined) {
                throw new RequiredError('project_name','Required parameter project_name was null or undefined when calling updateProject.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProject.');
            }
            const localVarPath = `/api/v1/{owner}/{project.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project.name"}}`, encodeURIComponent(String(project_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Project" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProjectSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateProjectSettings.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProjectSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectSettings" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateProjectTeams.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateProjectTeams.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProjectTeams.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectTeams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadProjectArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadProjectArtifact.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/artifacts/{uuid}/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsV1Api - functional programming interface
 * @export
 */
export const ProjectsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).archiveProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).bookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new project
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).createProject(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).deleteProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Disbale project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).disableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).enableProjectCI(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchProjectTeams(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectTeams> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).fetchProjectTeams(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).getProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettings(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectSettings> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).getProjectSettings(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listArchivedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listBookmarkedProjects(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List project names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listProjectNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List projects
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListProjectsResponse> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).listProjects(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).patchProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectSettings> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).patchProjectSettings(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectTeams> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).patchProjectTeams(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).restoreProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unbookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).unbookmarkProject(owner, project, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Project> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).updateProject(owner, project_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectSettings> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).updateProjectSettings(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ProjectTeams> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).updateProjectTeams(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectsV1ApiFetchParamCreator(configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectsV1Api - factory interface
 * @export
 */
export const ProjectsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).archiveProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).bookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new project
         * @param {string} owner Owner of the namespace
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(owner: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).createProject(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).deleteProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Disbale project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).disableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable project CI
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProjectCI(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).enableProjectCI(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchProjectTeams(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).fetchProjectTeams(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).getProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettings(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).getProjectSettings(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listArchivedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked projects for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listBookmarkedProjects(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List project names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listProjectNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List projects
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return ProjectsV1ApiFp(configuration).listProjects(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).patchProject(owner, project_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
            return ProjectsV1ApiFp(configuration).patchProjectSettings(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
            return ProjectsV1ApiFp(configuration).patchProjectTeams(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).restoreProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unbookmark project
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkProject(owner: string, project: string, options?: any) {
            return ProjectsV1ApiFp(configuration).unbookmarkProject(owner, project, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project
         * @param {string} owner Owner of the namespace
         * @param {string} project_name Required name
         * @param {V1Project} body Project body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(owner: string, project_name: string, body: V1Project, options?: any) {
            return ProjectsV1ApiFp(configuration).updateProject(owner, project_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectSettings} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
            return ProjectsV1ApiFp(configuration).updateProjectSettings(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update project teams
         * @param {string} owner Owner of the namespace
         * @param {string} project Project name
         * @param {V1ProjectTeams} body Project settings body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
            return ProjectsV1ApiFp(configuration).updateProjectTeams(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload artifact to a store via project access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return ProjectsV1ApiFp(configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectsV1Api - object-oriented interface
 * @export
 * @class ProjectsV1Api
 * @extends {BaseAPI}
 */
export class ProjectsV1Api extends BaseAPI {
    /**
     * 
     * @summary Archive project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public archiveProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).archiveProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public bookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).bookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new project
     * @param {string} owner Owner of the namespace
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public createProject(owner: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).createProject(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public deleteProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).deleteProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Disbale project CI
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public disableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).disableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enable project CI
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public enableProjectCI(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).enableProjectCI(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get project teams
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public fetchProjectTeams(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).fetchProjectTeams(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public getProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).getProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Project settings
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public getProjectSettings(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).getProjectSettings(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived projects for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listArchivedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listArchivedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked projects for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listBookmarkedProjects(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listBookmarkedProjects(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List project names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listProjectNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listProjectNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List projects
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public listProjects(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).listProjects(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public patchProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).patchProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project settings
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectSettings} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public patchProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
        return ProjectsV1ApiFp(this.configuration).patchProjectSettings(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch project teams
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectTeams} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public patchProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
        return ProjectsV1ApiFp(this.configuration).patchProjectTeams(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public restoreProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).restoreProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unbookmark project
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public unbookmarkProject(owner: string, project: string, options?: any) {
        return ProjectsV1ApiFp(this.configuration).unbookmarkProject(owner, project, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project
     * @param {string} owner Owner of the namespace
     * @param {string} project_name Required name
     * @param {V1Project} body Project body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public updateProject(owner: string, project_name: string, body: V1Project, options?: any) {
        return ProjectsV1ApiFp(this.configuration).updateProject(owner, project_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project settings
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectSettings} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public updateProjectSettings(owner: string, project: string, body: V1ProjectSettings, options?: any) {
        return ProjectsV1ApiFp(this.configuration).updateProjectSettings(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update project teams
     * @param {string} owner Owner of the namespace
     * @param {string} project Project name
     * @param {V1ProjectTeams} body Project settings body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public updateProjectTeams(owner: string, project: string, body: V1ProjectTeams, options?: any) {
        return ProjectsV1ApiFp(this.configuration).updateProjectTeams(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload artifact to a store via project access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsV1Api
     */
    public uploadProjectArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return ProjectsV1ApiFp(this.configuration).uploadProjectArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * QueuesV1Api - fetch parameter creator
 * @export
 */
export const QueuesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create queue
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent that consumes the queue
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueue(owner: string, agent: string, body: V1Queue, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createQueue.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling createQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Queue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete queue
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(owner: string, agent: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteQueue.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling deleteQueue.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get queue
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(owner: string, agent: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getQueue.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling getQueue.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization level queues names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listOrganizationQueueNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/queues/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List organization level queues
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listOrganizationQueues.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/queues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List queues names
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listQueueNames.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling listQueueNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List queues
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listQueues.');
            }
            // verify required parameter 'agent' is not null or undefined
            if (agent === null || agent === undefined) {
                throw new RequiredError('agent','Required parameter agent was null or undefined when calling listQueues.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{agent}/queues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"agent"}}`, encodeURIComponent(String(agent)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch queue
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchQueue.');
            }
            // verify required parameter 'queue_agent' is not null or undefined
            if (queue_agent === null || queue_agent === undefined) {
                throw new RequiredError('queue_agent','Required parameter queue_agent was null or undefined when calling patchQueue.');
            }
            // verify required parameter 'queue_uuid' is not null or undefined
            if (queue_uuid === null || queue_uuid === undefined) {
                throw new RequiredError('queue_uuid','Required parameter queue_uuid was null or undefined when calling patchQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{queue.agent}/queues/{queue.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"queue.agent"}}`, encodeURIComponent(String(queue_agent)))
                .replace(`{${"queue.uuid"}}`, encodeURIComponent(String(queue_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Queue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update queue
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateQueue.');
            }
            // verify required parameter 'queue_agent' is not null or undefined
            if (queue_agent === null || queue_agent === undefined) {
                throw new RequiredError('queue_agent','Required parameter queue_agent was null or undefined when calling updateQueue.');
            }
            // verify required parameter 'queue_uuid' is not null or undefined
            if (queue_uuid === null || queue_uuid === undefined) {
                throw new RequiredError('queue_uuid','Required parameter queue_uuid was null or undefined when calling updateQueue.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateQueue.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/agents/{queue.agent}/queues/{queue.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"queue.agent"}}`, encodeURIComponent(String(queue_agent)))
                .replace(`{${"queue.uuid"}}`, encodeURIComponent(String(queue_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Queue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueuesV1Api - functional programming interface
 * @export
 */
export const QueuesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create queue
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent that consumes the queue
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueue(owner: string, agent: string, body: V1Queue, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Agent> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).createQueue(owner, agent, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete queue
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(owner: string, agent: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).deleteQueue(owner, agent, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get queue
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(owner: string, agent: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Queue> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).getQueue(owner, agent, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List organization level queues names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).listOrganizationQueueNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List organization level queues
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).listOrganizationQueues(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List queues names
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).listQueueNames(owner, agent, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List queues
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListQueuesResponse> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).listQueues(owner, agent, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch queue
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Queue> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).patchQueue(owner, queue_agent, queue_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update queue
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Queue> {
            const localVarFetchArgs = QueuesV1ApiFetchParamCreator(configuration).updateQueue(owner, queue_agent, queue_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueuesV1Api - factory interface
 * @export
 */
export const QueuesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create queue
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent that consumes the queue
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQueue(owner: string, agent: string, body: V1Queue, options?: any) {
            return QueuesV1ApiFp(configuration).createQueue(owner, agent, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete queue
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(owner: string, agent: string, uuid: string, options?: any) {
            return QueuesV1ApiFp(configuration).deleteQueue(owner, agent, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get queue
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent managing the resource
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueue(owner: string, agent: string, uuid: string, options?: any) {
            return QueuesV1ApiFp(configuration).getQueue(owner, agent, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List organization level queues names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).listOrganizationQueueNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List organization level queues
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).listOrganizationQueues(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List queues names
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).listQueueNames(owner, agent, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List queues
         * @param {string} owner Owner of the namespace
         * @param {string} agent Agent man managing the resource
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return QueuesV1ApiFp(configuration).listQueues(owner, agent, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch queue
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
            return QueuesV1ApiFp(configuration).patchQueue(owner, queue_agent, queue_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update queue
         * @param {string} owner Owner of the namespace
         * @param {string} queue_agent Agent
         * @param {string} queue_uuid UUID
         * @param {V1Queue} body Queue body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
            return QueuesV1ApiFp(configuration).updateQueue(owner, queue_agent, queue_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * QueuesV1Api - object-oriented interface
 * @export
 * @class QueuesV1Api
 * @extends {BaseAPI}
 */
export class QueuesV1Api extends BaseAPI {
    /**
     * 
     * @summary Create queue
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent that consumes the queue
     * @param {V1Queue} body Queue body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public createQueue(owner: string, agent: string, body: V1Queue, options?: any) {
        return QueuesV1ApiFp(this.configuration).createQueue(owner, agent, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete queue
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent managing the resource
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public deleteQueue(owner: string, agent: string, uuid: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).deleteQueue(owner, agent, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get queue
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent managing the resource
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public getQueue(owner: string, agent: string, uuid: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).getQueue(owner, agent, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List organization level queues names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public listOrganizationQueueNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).listOrganizationQueueNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List organization level queues
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public listOrganizationQueues(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).listOrganizationQueues(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List queues names
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent man managing the resource
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public listQueueNames(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).listQueueNames(owner, agent, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List queues
     * @param {string} owner Owner of the namespace
     * @param {string} agent Agent man managing the resource
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public listQueues(owner: string, agent: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return QueuesV1ApiFp(this.configuration).listQueues(owner, agent, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch queue
     * @param {string} owner Owner of the namespace
     * @param {string} queue_agent Agent
     * @param {string} queue_uuid UUID
     * @param {V1Queue} body Queue body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public patchQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
        return QueuesV1ApiFp(this.configuration).patchQueue(owner, queue_agent, queue_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update queue
     * @param {string} owner Owner of the namespace
     * @param {string} queue_agent Agent
     * @param {string} queue_uuid UUID
     * @param {V1Queue} body Queue body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueuesV1Api
     */
    public updateQueue(owner: string, queue_agent: string, queue_uuid: string, body: V1Queue, options?: any) {
        return QueuesV1ApiFp(this.configuration).updateQueue(owner, queue_agent, queue_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RunProfilesV1Api - fetch parameter creator
 * @export
 */
export const RunProfilesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create run profile
         * @param {string} owner Owner of the namespace
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunProfile(owner: string, body: V1RunProfile, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRunProfile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunProfile(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRunProfile.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunProfile(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunProfile.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List run profiles names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRunProfileNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List run profiles
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRunProfiles.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run profile
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchRunProfile.');
            }
            // verify required parameter 'run_profile_uuid' is not null or undefined
            if (run_profile_uuid === null || run_profile_uuid === undefined) {
                throw new RequiredError('run_profile_uuid','Required parameter run_profile_uuid was null or undefined when calling patchRunProfile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{run_profile.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"run_profile.uuid"}}`, encodeURIComponent(String(run_profile_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run profile
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRunProfile.');
            }
            // verify required parameter 'run_profile_uuid' is not null or undefined
            if (run_profile_uuid === null || run_profile_uuid === undefined) {
                throw new RequiredError('run_profile_uuid','Required parameter run_profile_uuid was null or undefined when calling updateRunProfile.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRunProfile.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/run_profiles/{run_profile.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"run_profile.uuid"}}`, encodeURIComponent(String(run_profile_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunProfile" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunProfilesV1Api - functional programming interface
 * @export
 */
export const RunProfilesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create run profile
         * @param {string} owner Owner of the namespace
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunProfile(owner: string, body: V1RunProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).createRunProfile(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunProfile(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).deleteRunProfile(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunProfile(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).getRunProfile(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List run profiles names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunProfilesResponse> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).listRunProfileNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List run profiles
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunProfilesResponse> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).listRunProfiles(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run profile
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).patchRunProfile(owner, run_profile_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run profile
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunProfile> {
            const localVarFetchArgs = RunProfilesV1ApiFetchParamCreator(configuration).updateRunProfile(owner, run_profile_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunProfilesV1Api - factory interface
 * @export
 */
export const RunProfilesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create run profile
         * @param {string} owner Owner of the namespace
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunProfile(owner: string, body: V1RunProfile, options?: any) {
            return RunProfilesV1ApiFp(configuration).createRunProfile(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunProfile(owner: string, uuid: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).deleteRunProfile(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run profile
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunProfile(owner: string, uuid: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).getRunProfile(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List run profiles names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).listRunProfileNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List run profiles
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunProfilesV1ApiFp(configuration).listRunProfiles(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run profile
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
            return RunProfilesV1ApiFp(configuration).patchRunProfile(owner, run_profile_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run profile
         * @param {string} owner Owner of the namespace
         * @param {string} run_profile_uuid UUID
         * @param {V1RunProfile} body Artifact store body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
            return RunProfilesV1ApiFp(configuration).updateRunProfile(owner, run_profile_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * RunProfilesV1Api - object-oriented interface
 * @export
 * @class RunProfilesV1Api
 * @extends {BaseAPI}
 */
export class RunProfilesV1Api extends BaseAPI {
    /**
     * 
     * @summary Create run profile
     * @param {string} owner Owner of the namespace
     * @param {V1RunProfile} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public createRunProfile(owner: string, body: V1RunProfile, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).createRunProfile(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run profile
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public deleteRunProfile(owner: string, uuid: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).deleteRunProfile(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run profile
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public getRunProfile(owner: string, uuid: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).getRunProfile(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List run profiles names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public listRunProfileNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).listRunProfileNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List run profiles
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public listRunProfiles(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).listRunProfiles(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run profile
     * @param {string} owner Owner of the namespace
     * @param {string} run_profile_uuid UUID
     * @param {V1RunProfile} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public patchRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).patchRunProfile(owner, run_profile_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run profile
     * @param {string} owner Owner of the namespace
     * @param {string} run_profile_uuid UUID
     * @param {V1RunProfile} body Artifact store body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunProfilesV1Api
     */
    public updateRunProfile(owner: string, run_profile_uuid: string, body: V1RunProfile, options?: any) {
        return RunProfilesV1ApiFp(this.configuration).updateRunProfile(owner, run_profile_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * RunsV1Api - fetch parameter creator
 * @export
 */
export const RunsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling archiveRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling archiveRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/archive`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling bookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling bookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/bookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Collect run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectRunLogs(namespace: string, owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling collectRunLogs.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling collectRunLogs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling collectRunLogs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling collectRunLogs.');
            }
            const localVarPath = `/streams/v1/{namespace}/_internal/{owner}/{project}/runs/{uuid}/logs`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the notification will be assigned
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling copyRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling copyRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling copyRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling copyRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/copy`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {V1OperationBody} body operation object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1OperationBody, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1OperationBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create bulk run run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1RunArtifacts} body Run Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunArtifactsLineage(owner: string, project: string, uuid: string, body: V1RunArtifacts, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRunArtifactsLineage.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRunArtifactsLineage.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createRunArtifactsLineage.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunArtifactsLineage.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1RunArtifacts" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling createRunStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createRunStatus.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1EntityStatusBodyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete run artifact lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRunArtifactLineage.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRunArtifactLineage.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteRunArtifactLineage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling deleteRunArtifactLineage.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (runs !== undefined) {
                localVarQueryParameter['runs'] = runs;
            }

            if (orient !== undefined) {
                localVarQueryParameter['orient'] = orient;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling deleteRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get multi runs events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [uuid] Uuid identifier of the entity.
         * @param {string} [name] Artifact name.
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiRunEvents(namespace: string, owner: string, project: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', uuid?: string, name?: string, names?: string, runs?: string, orient?: string, path?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMultiRunEvents.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getMultiRunEvents.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getMultiRunEvents.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling getMultiRunEvents.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/multi/events/{kind}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (runs !== undefined) {
                localVarQueryParameter['runs'] = runs;
            }

            if (orient !== undefined) {
                localVarQueryParameter['orient'] = orient;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifact
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {boolean} [stream] Whether to stream the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifact(namespace: string, owner: string, project: string, uuid: string, path?: string, stream?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRunArtifact.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifact.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifact`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifactLineage.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifactLineage.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifactLineage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRunArtifactLineage.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage/{name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (runs !== undefined) {
                localVarQueryParameter['runs'] = runs;
            }

            if (orient !== undefined) {
                localVarQueryParameter['orient'] = orient;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifacts(namespace: string, owner: string, project: string, uuid: string, path?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRunArtifacts.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifacts.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifacts.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifacts.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsLineage(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifactsLineage.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifactsLineage.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifactsLineage.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsLineageNames(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifactsLineageNames.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifactsLineageNames.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifactsLineageNames.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts_lineage/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run artifacts tree
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} [name] Artifact name.
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsTree(namespace: string, owner: string, project: string, uuid: string, name?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRunArtifactsTree.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunArtifactsTree.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunArtifactsTree.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunArtifactsTree.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/artifacts/tree`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (runs !== undefined) {
                localVarQueryParameter['runs'] = runs;
            }

            if (orient !== undefined) {
                localVarQueryParameter['orient'] = orient;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [name] Artifact name.
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunEvents(namespace: string, owner: string, project: string, uuid: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', name?: string, names?: string, runs?: string, orient?: string, path?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRunEvents.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunEvents.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunEvents.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunEvents.');
            }
            // verify required parameter 'kind' is not null or undefined
            if (kind === null || kind === undefined) {
                throw new RequiredError('kind','Required parameter kind was null or undefined when calling getRunEvents.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/events/{kind}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"kind"}}`, encodeURIComponent(String(kind)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (runs !== undefined) {
                localVarQueryParameter['runs'] = runs;
            }

            if (orient !== undefined) {
                localVarQueryParameter['orient'] = orient;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {Date} [last_time] last time.
         * @param {string} [last_file] last file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs(namespace: string, owner: string, project: string, uuid: string, last_time?: Date, last_file?: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRunLogs.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunLogs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunLogs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunLogs.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/logs`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (last_time !== undefined) {
                localVarQueryParameter['last_time'] = (last_time as any).toISOString();
            }

            if (last_file !== undefined) {
                localVarQueryParameter['last_file'] = last_file;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Run namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunNamespace(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunNamespace.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunNamespace.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunNamespace.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/namespace`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Run settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunSettings(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunSettings.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunSettings.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunSettings.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/settings`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling getRunStatuses.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getRunStatuses.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/statuses`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling impersonateToken.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling impersonateToken.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling impersonateToken.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/impersonate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling invalidateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling invalidateRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invalidateRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/invalidate`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listArchivedRuns.');
            }
            const localVarPath = `/api/v1/archives/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling listBookmarkedRuns.');
            }
            const localVarPath = `/api/v1/bookmarks/{user}/runs`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunsIo(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listRunsIo.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling listRunsIo.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/io`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Notify run status
         * @param {string} namespace Na,espace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityNotificationBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyRunStatus(namespace: string, owner: string, project: string, uuid: string, body: V1EntityNotificationBody, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling notifyRunStatus.');
            }
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling notifyRunStatus.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling notifyRunStatus.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling notifyRunStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling notifyRunStatus.');
            }
            const localVarPath = `/streams/v1/{namespace}/{owner}/{project}/runs/{uuid}/notify`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1EntityNotificationBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling patchRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling patchRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the notification will be assigned
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling restartRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling restartRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling restartRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling restartRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/restart`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling restoreRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling restoreRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/restore`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the notification will be assigned
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'entity_owner' is not null or undefined
            if (entity_owner === null || entity_owner === undefined) {
                throw new RequiredError('entity_owner','Required parameter entity_owner was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'entity_project' is not null or undefined
            if (entity_project === null || entity_project === undefined) {
                throw new RequiredError('entity_project','Required parameter entity_project was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'entity_uuid' is not null or undefined
            if (entity_uuid === null || entity_uuid === undefined) {
                throw new RequiredError('entity_uuid','Required parameter entity_uuid was null or undefined when calling resumeRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling resumeRun.');
            }
            const localVarPath = `/api/v1/{entity.owner}/{entity.project}/runs/{entity.uuid}/resume`
                .replace(`{${"entity.owner"}}`, encodeURIComponent(String(entity_owner)))
                .replace(`{${"entity.project"}}`, encodeURIComponent(String(entity_project)))
                .replace(`{${"entity.uuid"}}`, encodeURIComponent(String(entity_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling startRunTensorboard.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling startRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ProjectEntityResourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRunTensorboard.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling stopRunTensorboard.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/tensorboard/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling stopRuns.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling stopRuns.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Uuids" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling unbookmarkRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling unbookmarkRun.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling unbookmarkRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/unbookmark`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateRun.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling updateRun.');
            }
            // verify required parameter 'run_uuid' is not null or undefined
            if (run_uuid === null || run_uuid === undefined) {
                throw new RequiredError('run_uuid','Required parameter run_uuid was null or undefined when calling updateRun.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateRun.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{run.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"run.uuid"}}`, encodeURIComponent(String(run_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Run" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadRunArtifact.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadRunArtifact.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/artifacts/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling uploadRunLogs.');
            }
            // verify required parameter 'uploadfile' is not null or undefined
            if (uploadfile === null || uploadfile === undefined) {
                throw new RequiredError('uploadfile','Required parameter uploadfile was null or undefined when calling uploadRunLogs.');
            }
            const localVarPath = `/api/v1/{owner}/{project}/runs/{uuid}/logs/upload`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"project"}}`, encodeURIComponent(String(project)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }

            if (uploadfile !== undefined) {
                localVarFormParams.set('uploadfile', uploadfile as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunsV1Api - functional programming interface
 * @export
 */
export const RunsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).archiveRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).bookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Collect run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectRunLogs(namespace: string, owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).collectRunLogs(namespace, owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the notification will be assigned
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {V1OperationBody} body operation object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1OperationBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRun(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create bulk run run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1RunArtifacts} body Run Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunArtifactsLineage(owner: string, project: string, uuid: string, body: V1RunArtifacts, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRunArtifactsLineage(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).createRunStatus(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).deleteRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete run artifact lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).deleteRunArtifactLineage(owner, project, uuid, name, namespace, kind, names, runs, orient, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).deleteRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get multi runs events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [uuid] Uuid identifier of the entity.
         * @param {string} [name] Artifact name.
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiRunEvents(namespace: string, owner: string, project: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', uuid?: string, name?: string, names?: string, runs?: string, orient?: string, path?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EventsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getMultiRunEvents(namespace, owner, project, kind, uuid, name, names, runs, orient, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifact
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {boolean} [stream] Whether to stream the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifact(namespace: string, owner: string, project: string, uuid: string, path?: string, stream?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifact(namespace, owner, project, uuid, path, stream, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunArtifact> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifactLineage(owner, project, uuid, name, namespace, kind, names, runs, orient, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifacts(namespace: string, owner: string, project: string, uuid: string, path?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifacts(namespace, owner, project, uuid, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsLineage(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunArtifactsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifactsLineage(owner, project, uuid, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts lineage names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsLineageNames(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunArtifactsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifactsLineageNames(owner, project, uuid, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run artifacts tree
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} [name] Artifact name.
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsTree(namespace: string, owner: string, project: string, uuid: string, name?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ArtifactTreeResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunArtifactsTree(namespace, owner, project, uuid, name, kind, names, runs, orient, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [name] Artifact name.
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunEvents(namespace: string, owner: string, project: string, uuid: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', name?: string, names?: string, runs?: string, orient?: string, path?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1EventsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunEvents(namespace, owner, project, uuid, kind, name, names, runs, orient, path, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {Date} [last_time] last time.
         * @param {string} [last_file] last file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs(namespace: string, owner: string, project: string, uuid: string, last_time?: Date, last_file?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Logs> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunLogs(namespace, owner, project, uuid, last_time, last_file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Run namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunNamespace(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunSettings> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunNamespace(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get Run settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunSettings(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1RunSettings> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunSettings(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Status> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).getRunStatuses(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Auth> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).impersonateToken(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).invalidateRun(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).invalidateRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listArchivedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listBookmarkedRuns(user, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listRuns(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunsIo(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListRunsResponse> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).listRunsIo(owner, project, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Notify run status
         * @param {string} namespace Na,espace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityNotificationBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyRunStatus(namespace: string, owner: string, project: string, uuid: string, body: V1EntityNotificationBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).notifyRunStatus(namespace, owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).patchRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the notification will be assigned
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).restoreRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the notification will be assigned
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).startRunTensorboard(owner, project, uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRunTensorboard(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).stopRuns(owner, project, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).unbookmarkRun(owner, project, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Run> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).updateRun(owner, project, run_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunsV1ApiFetchParamCreator(configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunsV1Api - factory interface
 * @export
 */
export const RunsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Archive run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).archiveRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).bookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Collect run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectRunLogs(namespace: string, owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).collectRunLogs(namespace, owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run with copy
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the notification will be assigned
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {V1OperationBody} body operation object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(owner: string, project: string, body: V1OperationBody, options?: any) {
            return RunsV1ApiFp(configuration).createRun(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create bulk run run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1RunArtifacts} body Run Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunArtifactsLineage(owner: string, project: string, uuid: string, body: V1RunArtifacts, options?: any) {
            return RunsV1ApiFp(configuration).createRunArtifactsLineage(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityStatusBodyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
            return RunsV1ApiFp(configuration).createRunStatus(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).deleteRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete run artifact lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options?: any) {
            return RunsV1ApiFp(configuration).deleteRunArtifactLineage(owner, project, uuid, name, namespace, kind, names, runs, orient, path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).deleteRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get multi runs events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [uuid] Uuid identifier of the entity.
         * @param {string} [name] Artifact name.
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultiRunEvents(namespace: string, owner: string, project: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', uuid?: string, name?: string, names?: string, runs?: string, orient?: string, path?: string, options?: any) {
            return RunsV1ApiFp(configuration).getMultiRunEvents(namespace, owner, project, kind, uuid, name, names, runs, orient, path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifact
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {boolean} [stream] Whether to stream the file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifact(namespace: string, owner: string, project: string, uuid: string, path?: string, stream?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifact(namespace, owner, project, uuid, path, stream, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} name Artifact name
         * @param {string} [namespace] namespace.
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifactLineage(owner, project, uuid, name, namespace, kind, names, runs, orient, path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the experiement will be assigned
         * @param {string} uuid Unique integer identifier of the entity
         * @param {string} [path] Artifact filepath.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifacts(namespace: string, owner: string, project: string, uuid: string, path?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifacts(namespace, owner, project, uuid, path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts lineage
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsLineage(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifactsLineage(owner, project, uuid, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts lineage names
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsLineageNames(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifactsLineageNames(owner, project, uuid, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run artifacts tree
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {string} [name] Artifact name.
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunArtifactsTree(namespace: string, owner: string, project: string, uuid: string, name?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunArtifactsTree(namespace, owner, project, uuid, name, kind, names, runs, orient, path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run events
         * @param {string} namespace namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
         * @param {string} [name] Artifact name.
         * @param {string} [names] Names query param.
         * @param {string} [runs] Runs query param.
         * @param {string} [orient] Orient query param.
         * @param {string} [path] Path query param.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunEvents(namespace: string, owner: string, project: string, uuid: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', name?: string, names?: string, runs?: string, orient?: string, path?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunEvents(namespace, owner, project, uuid, kind, name, names, runs, orient, path, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run logs
         * @param {string} namespace 
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {Date} [last_time] last time.
         * @param {string} [last_file] last file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs(namespace: string, owner: string, project: string, uuid: string, last_time?: Date, last_file?: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunLogs(namespace, owner, project, uuid, last_time, last_file, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Run namespace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunNamespace(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunNamespace(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get Run settings
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunSettings(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunSettings(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get run status
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).getRunStatuses(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Impersonate run token
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        impersonateToken(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).impersonateToken(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).invalidateRun(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Invalidate runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).invalidateRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List archived runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listArchivedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List bookmarked runs for user
         * @param {string} user User
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listBookmarkedRuns(user, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listRuns(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunsIo(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return RunsV1ApiFp(configuration).listRunsIo(owner, project, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Notify run status
         * @param {string} namespace Na,espace
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1EntityNotificationBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyRunStatus(namespace: string, owner: string, project: string, uuid: string, body: V1EntityNotificationBody, options?: any) {
            return RunsV1ApiFp(configuration).notifyRunStatus(namespace, owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).patchRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restart run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the notification will be assigned
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Restore run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).restoreRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resume run
         * @param {string} entity_owner Owner of the namespace
         * @param {string} entity_project Project where the notification will be assigned
         * @param {string} entity_uuid Uuid identifier of the entity
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {V1ProjectEntityResourceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
            return RunsV1ApiFp(configuration).startRunTensorboard(owner, project, uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).stopRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop run tensorboard
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).stopRunTensorboard(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stop runs
         * @param {string} owner Owner of the namespace
         * @param {string} project Project under namesapce
         * @param {V1Uuids} body Uuids of the entities
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
            return RunsV1ApiFp(configuration).stopRuns(owner, project, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unbookmark run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the notification will be assigned
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
            return RunsV1ApiFp(configuration).unbookmarkRun(owner, project, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update run
         * @param {string} owner Owner of the namespace
         * @param {string} project Project where the run will be assigned
         * @param {string} run_uuid UUID
         * @param {V1Run} body Run object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
            return RunsV1ApiFp(configuration).updateRun(owner, project, run_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload an artifact file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload a logs file to a store via run access
         * @param {string} owner Owner of the namespace
         * @param {string} project Project having access to the store
         * @param {string} uuid Unique integer identifier of the entity
         * @param {any} uploadfile The file to upload.
         * @param {string} [path] File path query params.
         * @param {boolean} [overwrite] File path query params.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
            return RunsV1ApiFp(configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options)(fetch, basePath);
        },
    };
};

/**
 * RunsV1Api - object-oriented interface
 * @export
 * @class RunsV1Api
 * @extends {BaseAPI}
 */
export class RunsV1Api extends BaseAPI {
    /**
     * 
     * @summary Archive run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public archiveRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).archiveRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public bookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).bookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Collect run logs
     * @param {string} namespace 
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public collectRunLogs(namespace: string, owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).collectRunLogs(namespace, owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run with copy
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the notification will be assigned
     * @param {string} entity_uuid Uuid identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public copyRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).copyRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {V1OperationBody} body operation object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRun(owner: string, project: string, body: V1OperationBody, options?: any) {
        return RunsV1ApiFp(this.configuration).createRun(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create bulk run run artifacts lineage
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1RunArtifacts} body Run Artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRunArtifactsLineage(owner: string, project: string, uuid: string, body: V1RunArtifacts, options?: any) {
        return RunsV1ApiFp(this.configuration).createRunArtifactsLineage(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1EntityStatusBodyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public createRunStatus(owner: string, project: string, uuid: string, body: V1EntityStatusBodyRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).createRunStatus(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public deleteRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).deleteRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete run artifact lineage
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {string} name Artifact name
     * @param {string} [namespace] namespace.
     * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
     * @param {string} [names] Names query param.
     * @param {string} [runs] Runs query param.
     * @param {string} [orient] Orient query param.
     * @param {string} [path] Path query param.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public deleteRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).deleteRunArtifactLineage(owner, project, uuid, name, namespace, kind, names, runs, orient, path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public deleteRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).deleteRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get multi runs events
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
     * @param {string} [uuid] Uuid identifier of the entity.
     * @param {string} [name] Artifact name.
     * @param {string} [names] Names query param.
     * @param {string} [runs] Runs query param.
     * @param {string} [orient] Orient query param.
     * @param {string} [path] Path query param.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getMultiRunEvents(namespace: string, owner: string, project: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', uuid?: string, name?: string, names?: string, runs?: string, orient?: string, path?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getMultiRunEvents(namespace, owner, project, kind, uuid, name, names, runs, orient, path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifact
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {boolean} [stream] Whether to stream the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifact(namespace: string, owner: string, project: string, uuid: string, path?: string, stream?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifact(namespace, owner, project, uuid, path, stream, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts lineage
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {string} name Artifact name
     * @param {string} [namespace] namespace.
     * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
     * @param {string} [names] Names query param.
     * @param {string} [runs] Runs query param.
     * @param {string} [orient] Orient query param.
     * @param {string} [path] Path query param.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifactLineage(owner: string, project: string, uuid: string, name: string, namespace?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifactLineage(owner, project, uuid, name, namespace, kind, names, runs, orient, path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the experiement will be assigned
     * @param {string} uuid Unique integer identifier of the entity
     * @param {string} [path] Artifact filepath.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifacts(namespace: string, owner: string, project: string, uuid: string, path?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifacts(namespace, owner, project, uuid, path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts lineage
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifactsLineage(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifactsLineage(owner, project, uuid, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts lineage names
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifactsLineageNames(owner: string, project: string, uuid: string, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifactsLineageNames(owner, project, uuid, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run artifacts tree
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {string} [name] Artifact name.
     * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} [kind] The artifact kind.   - model: model  - audio: audio  - video: vidio  - histogram: histogram  - image: image  - tensor: tensor  - dataframe: dataframe  - chart: plotly/bokeh chart  - csv: Comma  - tsv: Tab  - psv: Pipe  - ssv: Space  - metric: Metric  - env: Env  - html: HTML  - text: Text  - file: File  - dir: Dir  - dockerfile: Dockerfile  - docker_image: docker image  - data: data  - coderef: coderef  - table: table
     * @param {string} [names] Names query param.
     * @param {string} [runs] Runs query param.
     * @param {string} [orient] Orient query param.
     * @param {string} [path] Path query param.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunArtifactsTree(namespace: string, owner: string, project: string, uuid: string, name?: string, kind?: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', names?: string, runs?: string, orient?: string, path?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunArtifactsTree(namespace, owner, project, uuid, name, kind, names, runs, orient, path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run events
     * @param {string} namespace namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table'} kind The artifact kind
     * @param {string} [name] Artifact name.
     * @param {string} [names] Names query param.
     * @param {string} [runs] Runs query param.
     * @param {string} [orient] Orient query param.
     * @param {string} [path] Path query param.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunEvents(namespace: string, owner: string, project: string, uuid: string, kind: 'model' | 'audio' | 'video' | 'histogram' | 'image' | 'tensor' | 'dataframe' | 'chart' | 'csv' | 'tsv' | 'psv' | 'ssv' | 'metric' | 'env' | 'html' | 'text' | 'file' | 'dir' | 'dockerfile' | 'docker_image' | 'data' | 'coderef' | 'table', name?: string, names?: string, runs?: string, orient?: string, path?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunEvents(namespace, owner, project, uuid, kind, name, names, runs, orient, path, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run logs
     * @param {string} namespace 
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {Date} [last_time] last time.
     * @param {string} [last_file] last file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunLogs(namespace: string, owner: string, project: string, uuid: string, last_time?: Date, last_file?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunLogs(namespace, owner, project, uuid, last_time, last_file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Run namespace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunNamespace(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunNamespace(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get Run settings
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunSettings(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunSettings(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get run status
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public getRunStatuses(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).getRunStatuses(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Impersonate run token
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public impersonateToken(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).impersonateToken(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public invalidateRun(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).invalidateRun(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Invalidate runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public invalidateRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).invalidateRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List archived runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listArchivedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listArchivedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List bookmarked runs for user
     * @param {string} user User
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listBookmarkedRuns(user: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listBookmarkedRuns(user, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listRuns(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listRuns(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public listRunsIo(owner: string, project: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return RunsV1ApiFp(this.configuration).listRunsIo(owner, project, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Notify run status
     * @param {string} namespace Na,espace
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1EntityNotificationBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public notifyRunStatus(namespace: string, owner: string, project: string, uuid: string, body: V1EntityNotificationBody, options?: any) {
        return RunsV1ApiFp(this.configuration).notifyRunStatus(namespace, owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public patchRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).patchRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restart run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the notification will be assigned
     * @param {string} entity_uuid Uuid identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public restartRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).restartRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Restore run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public restoreRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).restoreRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resume run
     * @param {string} entity_owner Owner of the namespace
     * @param {string} entity_project Project where the notification will be assigned
     * @param {string} entity_uuid Uuid identifier of the entity
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public resumeRun(entity_owner: string, entity_project: string, entity_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).resumeRun(entity_owner, entity_project, entity_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {V1ProjectEntityResourceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public startRunTensorboard(owner: string, project: string, uuid: string, body: V1ProjectEntityResourceRequest, options?: any) {
        return RunsV1ApiFp(this.configuration).startRunTensorboard(owner, project, uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop run tensorboard
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRunTensorboard(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRunTensorboard(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stop runs
     * @param {string} owner Owner of the namespace
     * @param {string} project Project under namesapce
     * @param {V1Uuids} body Uuids of the entities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public stopRuns(owner: string, project: string, body: V1Uuids, options?: any) {
        return RunsV1ApiFp(this.configuration).stopRuns(owner, project, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unbookmark run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the notification will be assigned
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public unbookmarkRun(owner: string, project: string, uuid: string, options?: any) {
        return RunsV1ApiFp(this.configuration).unbookmarkRun(owner, project, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update run
     * @param {string} owner Owner of the namespace
     * @param {string} project Project where the run will be assigned
     * @param {string} run_uuid UUID
     * @param {V1Run} body Run object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public updateRun(owner: string, project: string, run_uuid: string, body: V1Run, options?: any) {
        return RunsV1ApiFp(this.configuration).updateRun(owner, project, run_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload an artifact file to a store via run access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public uploadRunArtifact(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).uploadRunArtifact(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload a logs file to a store via run access
     * @param {string} owner Owner of the namespace
     * @param {string} project Project having access to the store
     * @param {string} uuid Unique integer identifier of the entity
     * @param {any} uploadfile The file to upload.
     * @param {string} [path] File path query params.
     * @param {boolean} [overwrite] File path query params.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunsV1Api
     */
    public uploadRunLogs(owner: string, project: string, uuid: string, uploadfile: any, path?: string, overwrite?: boolean, options?: any) {
        return RunsV1ApiFp(this.configuration).uploadRunLogs(owner, project, uuid, uploadfile, path, overwrite, options)(this.fetch, this.basePath);
    }

}

/**
 * SchemasV1Api - fetch parameter creator
 * @export
 */
export const SchemasV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get random
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noOp(options: any = {}): FetchArgs {
            const localVarPath = `/schemas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemasV1Api - functional programming interface
 * @export
 */
export const SchemasV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get random
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noOp(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Schemas> {
            const localVarFetchArgs = SchemasV1ApiFetchParamCreator(configuration).noOp(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SchemasV1Api - factory interface
 * @export
 */
export const SchemasV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get random
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        noOp(options?: any) {
            return SchemasV1ApiFp(configuration).noOp(options)(fetch, basePath);
        },
    };
};

/**
 * SchemasV1Api - object-oriented interface
 * @export
 * @class SchemasV1Api
 * @extends {BaseAPI}
 */
export class SchemasV1Api extends BaseAPI {
    /**
     * 
     * @summary Get random
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasV1Api
     */
    public noOp(options?: any) {
        return SchemasV1ApiFp(this.configuration).noOp(options)(this.fetch, this.basePath);
    }

}

/**
 * SearchesV1Api - fetch parameter creator
 * @export
 */
export const SearchesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create search
         * @param {string} owner Owner of the namespace
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling deleteSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getSearch.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling getSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List search names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listSearchNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List searches
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listSearches.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling patchSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, search_uuid: string, body: V1Search, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'search_uuid' is not null or undefined
            if (search_uuid === null || search_uuid === undefined) {
                throw new RequiredError('search_uuid','Required parameter search_uuid was null or undefined when calling updateSearch.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSearch.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/searches/{search.uuid}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"search.uuid"}}`, encodeURIComponent(String(search_uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Search" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchesV1Api - functional programming interface
 * @export
 */
export const SearchesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create search
         * @param {string} owner Owner of the namespace
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).createSearch(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).deleteSearch(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).getSearch(owner, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List search names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).listSearchNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List searches
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListSearchesResponse> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).listSearches(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).patchSearch(owner, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, search_uuid: string, body: V1Search, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Search> {
            const localVarFetchArgs = SearchesV1ApiFetchParamCreator(configuration).updateSearch(owner, search_uuid, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchesV1Api - factory interface
 * @export
 */
export const SearchesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create search
         * @param {string} owner Owner of the namespace
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSearch(owner: string, body: V1Search, options?: any) {
            return SearchesV1ApiFp(configuration).createSearch(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSearch(owner: string, uuid: string, options?: any) {
            return SearchesV1ApiFp(configuration).deleteSearch(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get search
         * @param {string} owner Owner of the namespace
         * @param {string} uuid Uuid identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(owner: string, uuid: string, options?: any) {
            return SearchesV1ApiFp(configuration).getSearch(owner, uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List search names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return SearchesV1ApiFp(configuration).listSearchNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List searches
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return SearchesV1ApiFp(configuration).listSearches(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchesV1ApiFp(configuration).patchSearch(owner, search_uuid, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update search
         * @param {string} owner Owner of the namespace
         * @param {string} search_uuid UUID
         * @param {V1Search} body Search body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
            return SearchesV1ApiFp(configuration).updateSearch(owner, search_uuid, body, options)(fetch, basePath);
        },
    };
};

/**
 * SearchesV1Api - object-oriented interface
 * @export
 * @class SearchesV1Api
 * @extends {BaseAPI}
 */
export class SearchesV1Api extends BaseAPI {
    /**
     * 
     * @summary Create search
     * @param {string} owner Owner of the namespace
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public createSearch(owner: string, body: V1Search, options?: any) {
        return SearchesV1ApiFp(this.configuration).createSearch(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete search
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public deleteSearch(owner: string, uuid: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).deleteSearch(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get search
     * @param {string} owner Owner of the namespace
     * @param {string} uuid Uuid identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public getSearch(owner: string, uuid: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).getSearch(owner, uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List search names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public listSearchNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).listSearchNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List searches
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public listSearches(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return SearchesV1ApiFp(this.configuration).listSearches(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch search
     * @param {string} owner Owner of the namespace
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public patchSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchesV1ApiFp(this.configuration).patchSearch(owner, search_uuid, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update search
     * @param {string} owner Owner of the namespace
     * @param {string} search_uuid UUID
     * @param {V1Search} body Search body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchesV1Api
     */
    public updateSearch(owner: string, search_uuid: string, body: V1Search, options?: any) {
        return SearchesV1ApiFp(this.configuration).updateSearch(owner, search_uuid, body, options)(this.fetch, this.basePath);
    }

}

/**
 * TeamsV1Api - fetch parameter creator
 * @export
 */
export const TeamsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create team
         * @param {string} owner Owner of the namespace
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(owner: string, body: V1Team, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Team" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create team member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamMember(owner: string, team: string, body: V1TeamMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling createTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling createTeamMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TeamMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete team
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(owner: string, team: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling deleteTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete team member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamMember(owner: string, team: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling deleteTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling deleteTeamMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling deleteTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get team
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(owner: string, team: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getTeam.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling getTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get team member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMember(owner: string, team: string, user: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling getTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling getTeamMember.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling getTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get team members
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listTeamMembers.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling listTeamMembers.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List teams names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listTeamNames.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/names`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List teams
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling listTeams.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch team
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam(owner: string, team_name: string, body: V1Team, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchTeam.');
            }
            // verify required parameter 'team_name' is not null or undefined
            if (team_name === null || team_name === undefined) {
                throw new RequiredError('team_name','Required parameter team_name was null or undefined when calling patchTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team.name"}}`, encodeURIComponent(String(team_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Team" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch tram member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling patchTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling patchTeamMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling patchTeamMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TeamMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update team
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(owner: string, team_name: string, body: V1Team, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'team_name' is not null or undefined
            if (team_name === null || team_name === undefined) {
                throw new RequiredError('team_name','Required parameter team_name was null or undefined when calling updateTeam.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTeam.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team.name}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team.name"}}`, encodeURIComponent(String(team_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1Team" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update team member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options: any = {}): FetchArgs {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling updateTeamMember.');
            }
            // verify required parameter 'team' is not null or undefined
            if (team === null || team === undefined) {
                throw new RequiredError('team','Required parameter team was null or undefined when calling updateTeamMember.');
            }
            // verify required parameter 'member_user' is not null or undefined
            if (member_user === null || member_user === undefined) {
                throw new RequiredError('member_user','Required parameter member_user was null or undefined when calling updateTeamMember.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTeamMember.');
            }
            const localVarPath = `/api/v1/orgs/{owner}/teams/{team}/members/{member.user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"team"}}`, encodeURIComponent(String(team)))
                .replace(`{${"member.user"}}`, encodeURIComponent(String(member_user)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1TeamMember" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsV1Api - functional programming interface
 * @export
 */
export const TeamsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create team
         * @param {string} owner Owner of the namespace
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(owner: string, body: V1Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).createTeam(owner, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create team member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamMember(owner: string, team: string, body: V1TeamMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).createTeamMember(owner, team, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete team
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(owner: string, team: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).deleteTeam(owner, team, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete team member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamMember(owner: string, team: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).deleteTeamMember(owner, team, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get team
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(owner: string, team: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).getTeam(owner, team, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get team member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMember(owner: string, team: string, user: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).getTeamMember(owner, team, user, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get team members
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListTeamMembersResponse> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).listTeamMembers(owner, team, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List teams names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListTeamsResponse> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).listTeamNames(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List teams
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1ListTeamsResponse> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).listTeams(owner, offset, limit, sort, query, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch team
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam(owner: string, team_name: string, body: V1Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).patchTeam(owner, team_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Patch tram member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).patchTeamMember(owner, team, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update team
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(owner: string, team_name: string, body: V1Team, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Team> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).updateTeam(owner, team_name, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update team member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1TeamMember> {
            const localVarFetchArgs = TeamsV1ApiFetchParamCreator(configuration).updateTeamMember(owner, team, member_user, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TeamsV1Api - factory interface
 * @export
 */
export const TeamsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create team
         * @param {string} owner Owner of the namespace
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(owner: string, body: V1Team, options?: any) {
            return TeamsV1ApiFp(configuration).createTeam(owner, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create team member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamMember(owner: string, team: string, body: V1TeamMember, options?: any) {
            return TeamsV1ApiFp(configuration).createTeamMember(owner, team, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete team
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeam(owner: string, team: string, options?: any) {
            return TeamsV1ApiFp(configuration).deleteTeam(owner, team, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete team member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamMember(owner: string, team: string, user: string, options?: any) {
            return TeamsV1ApiFp(configuration).deleteTeamMember(owner, team, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get team
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeam(owner: string, team: string, options?: any) {
            return TeamsV1ApiFp(configuration).getTeam(owner, team, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get team member details
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {string} user Member under team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMember(owner: string, team: string, user: string, options?: any) {
            return TeamsV1ApiFp(configuration).getTeamMember(owner, team, user, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get team members
         * @param {string} owner Owner of the namespace
         * @param {string} team Team under namesapce
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return TeamsV1ApiFp(configuration).listTeamMembers(owner, team, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List teams names
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return TeamsV1ApiFp(configuration).listTeamNames(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List teams
         * @param {string} owner Owner of the namespace
         * @param {number} [offset] Pagination offset.
         * @param {number} [limit] Limit size.
         * @param {string} [sort] Sort to order the search.
         * @param {string} [query] Query filter the search search.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
            return TeamsV1ApiFp(configuration).listTeams(owner, offset, limit, sort, query, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch team
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeam(owner: string, team_name: string, body: V1Team, options?: any) {
            return TeamsV1ApiFp(configuration).patchTeam(owner, team_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch tram member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
            return TeamsV1ApiFp(configuration).patchTeamMember(owner, team, member_user, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update team
         * @param {string} owner Owner of the namespace
         * @param {string} team_name Name
         * @param {V1Team} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(owner: string, team_name: string, body: V1Team, options?: any) {
            return TeamsV1ApiFp(configuration).updateTeam(owner, team_name, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update team member
         * @param {string} owner Owner of the namespace
         * @param {string} team Team
         * @param {string} member_user User
         * @param {V1TeamMember} body Team body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
            return TeamsV1ApiFp(configuration).updateTeamMember(owner, team, member_user, body, options)(fetch, basePath);
        },
    };
};

/**
 * TeamsV1Api - object-oriented interface
 * @export
 * @class TeamsV1Api
 * @extends {BaseAPI}
 */
export class TeamsV1Api extends BaseAPI {
    /**
     * 
     * @summary Create team
     * @param {string} owner Owner of the namespace
     * @param {V1Team} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public createTeam(owner: string, body: V1Team, options?: any) {
        return TeamsV1ApiFp(this.configuration).createTeam(owner, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create team member
     * @param {string} owner Owner of the namespace
     * @param {string} team Team
     * @param {V1TeamMember} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public createTeamMember(owner: string, team: string, body: V1TeamMember, options?: any) {
        return TeamsV1ApiFp(this.configuration).createTeamMember(owner, team, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete team
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public deleteTeam(owner: string, team: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).deleteTeam(owner, team, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete team member details
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {string} user Member under team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public deleteTeamMember(owner: string, team: string, user: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).deleteTeamMember(owner, team, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get team
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public getTeam(owner: string, team: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).getTeam(owner, team, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get team member details
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {string} user Member under team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public getTeamMember(owner: string, team: string, user: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).getTeamMember(owner, team, user, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get team members
     * @param {string} owner Owner of the namespace
     * @param {string} team Team under namesapce
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public listTeamMembers(owner: string, team: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).listTeamMembers(owner, team, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List teams names
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public listTeamNames(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).listTeamNames(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List teams
     * @param {string} owner Owner of the namespace
     * @param {number} [offset] Pagination offset.
     * @param {number} [limit] Limit size.
     * @param {string} [sort] Sort to order the search.
     * @param {string} [query] Query filter the search search.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public listTeams(owner: string, offset?: number, limit?: number, sort?: string, query?: string, options?: any) {
        return TeamsV1ApiFp(this.configuration).listTeams(owner, offset, limit, sort, query, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch team
     * @param {string} owner Owner of the namespace
     * @param {string} team_name Name
     * @param {V1Team} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public patchTeam(owner: string, team_name: string, body: V1Team, options?: any) {
        return TeamsV1ApiFp(this.configuration).patchTeam(owner, team_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Patch tram member
     * @param {string} owner Owner of the namespace
     * @param {string} team Team
     * @param {string} member_user User
     * @param {V1TeamMember} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public patchTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
        return TeamsV1ApiFp(this.configuration).patchTeamMember(owner, team, member_user, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update team
     * @param {string} owner Owner of the namespace
     * @param {string} team_name Name
     * @param {V1Team} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public updateTeam(owner: string, team_name: string, body: V1Team, options?: any) {
        return TeamsV1ApiFp(this.configuration).updateTeam(owner, team_name, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update team member
     * @param {string} owner Owner of the namespace
     * @param {string} team Team
     * @param {string} member_user User
     * @param {V1TeamMember} body Team body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsV1Api
     */
    public updateTeamMember(owner: string, team: string, member_user: string, body: V1TeamMember, options?: any) {
        return TeamsV1ApiFp(this.configuration).updateTeamMember(owner, team, member_user, body, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersV1Api - fetch parameter creator
 * @export
 */
export const UsersV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersV1Api - functional programming interface
 * @export
 */
export const UsersV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1User> {
            const localVarFetchArgs = UsersV1ApiFetchParamCreator(configuration).getUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersV1Api - factory interface
 * @export
 */
export const UsersV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UsersV1ApiFp(configuration).getUser(options)(fetch, basePath);
        },
    };
};

/**
 * UsersV1Api - object-oriented interface
 * @export
 * @class UsersV1Api
 * @extends {BaseAPI}
 */
export class UsersV1Api extends BaseAPI {
    /**
     * 
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersV1Api
     */
    public getUser(options?: any) {
        return UsersV1ApiFp(this.configuration).getUser(options)(this.fetch, this.basePath);
    }

}

/**
 * VersionsV1Api - fetch parameter creator
 * @export
 */
export const VersionsV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get log handler
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/log_handler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsV1Api - functional programming interface
 * @export
 */
export const VersionsV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get log handler
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1LogHandler> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).getLogHandler(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V1Versions> {
            const localVarFetchArgs = VersionsV1ApiFetchParamCreator(configuration).getVersions(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VersionsV1Api - factory interface
 * @export
 */
export const VersionsV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get log handler
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogHandler(options?: any) {
            return VersionsV1ApiFp(configuration).getLogHandler(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersions(options?: any) {
            return VersionsV1ApiFp(configuration).getVersions(options)(fetch, basePath);
        },
    };
};

/**
 * VersionsV1Api - object-oriented interface
 * @export
 * @class VersionsV1Api
 * @extends {BaseAPI}
 */
export class VersionsV1Api extends BaseAPI {
    /**
     * 
     * @summary Get log handler
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public getLogHandler(options?: any) {
        return VersionsV1ApiFp(this.configuration).getLogHandler(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsV1Api
     */
    public getVersions(options?: any) {
        return VersionsV1ApiFp(this.configuration).getVersions(options)(this.fetch, this.basePath);
    }

}

